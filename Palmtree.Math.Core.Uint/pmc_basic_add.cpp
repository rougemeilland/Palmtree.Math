/*
 * The MIT License
 *
 * Copyright 2019 Palmtree Software.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include "pmc_uint_internal.h"
#include "pmc_basic.h"
#include "pmc_autogenerated_inline_func.h"

namespace Palmtree::Math::Core::Internal
{

    __CARRY_T BasicOperatorEngine::Carry(__CARRY_T c, _UBASIC_T u_buf)
    {
        __UNIT_TYPE* u_ptr = u_buf.BLOCK;
        __UNIT_TYPE u_count = u_buf.BLOCK_COUNT;

        // 繰り上がりを続く限り行う
        for (;;)
        {
            if (u_count <= 0)
            {
                // u の最上位まで達してしまった場合

                return (c != 0);
            }
            else if (c)
            {
                // u の最上位に達しておらず、かつキャリーが立っている場合

                // 繰り上がりを継続する
                c = _ADD_UNIT(c, *u_ptr, 0, u_ptr);
                ++u_ptr;
                --u_count;
            }
            else
            {
                // u の最上位に達しておらず、かつキャリーが立っていない場合

                // 繰り上がりを中断し、正常復帰する。
                return (false);
            }
        }
    }

    __CARRY_T BasicOperatorEngine::Carry(__CARRY_T c, _UBASIC_T u_buf, _UBASIC_T w_buf)
    {
        __UNIT_TYPE* u_ptr = u_buf.BLOCK;
        __UNIT_TYPE u_count = u_buf.BLOCK_COUNT;
        __UNIT_TYPE* w_ptr = w_buf.BLOCK;
        __UNIT_TYPE w_count = w_buf.BLOCK_COUNT;

        // 繰り上がりを続く限り行う
        for (;;)
        {
            if (u_count <= 0)
            {
                // u の最上位まで達してしまった場合

                if (c)
                {
                    // かつそれでも繰り上がりを行う必要がある場合
                    if (w_count <= 0)
                    {
                        // しかし w がもう終端に達してしまった場合

                        // キャリーの発生を呼び出し元に通知する
                        return (true);
                    }
                    *w_ptr++ = 1;
                    --w_count;
                }

                // u の最上位に達してしまった場合はいずれにしろループを中断して正常復帰する。
                break;
            }
            else if (c)
            {
                // u の最上位に達しておらず、かつキャリーが立っている場合

                // 繰り上がりを継続する
                c = _ADD_UNIT(c, *u_ptr++, 0, w_ptr++);
                --u_count;
                --w_count;
            }
            else
            {
                // u の最上位に達しておらず、かつキャリーが立っていない場合

                // 繰り上がりを中断し、u の残りのデータを z にそのまま複写し、正常復帰する。
                _COPY_MEMORY_UNIT(w_ptr, u_ptr, u_count);
                w_ptr += u_count;
                u_ptr += u_count;
                w_count -= u_count;
                u_count = 0;
                break;
            }
        }
        _ZERO_MEMORY_UNIT(w_ptr, w_count);
        return (false);
    }

    // この関数を static にすると 32bit 版の gcc で以下のエラーが発生する。最適化で悪さしてる模様? 
    // error: unsupported size for integer register
#ifndef _M_IX86
    static
#endif
    __CARRY_T Add_UX_1W(BasicOperatorEngine& ep, _UBASIC_T& u_buf, __UNIT_TYPE v)
    {
#ifdef _DEBUG
        if (u_buf.BLOCK_COUNT < 1)
            throw InternalErrorException(L"予期しないルートに到達しました。", L"pmc_add.cpp;Add_UX_1W;1");
#endif
        // 最下桁の加算を行う
        __CARRY_T c = _ADD_UNIT(0, u_buf.BLOCK[0], v, &u_buf.BLOCK[0]);

        // 残りの桁の繰上りを行い復帰する。
        return (ep.Carry(c, u_buf.Region(1)));
    }

    static __CARRY_T Add_UX_1W(BasicOperatorEngine& ep, _UBASIC_T u_buf, __UNIT_TYPE v, _UBASIC_T& w_buf)
    {
#ifdef _DEBUG
        if (u_buf.BLOCK_COUNT < 1)
            throw InternalErrorException(L"予期しないルートに到達しました。", L"pmc_add.cpp;Add_UX_1W;1");
        if (w_buf.BLOCK_COUNT < u_buf.BLOCK_COUNT + 1)
            throw InternalErrorException(L"予期しないルートに到達しました。", L"pmc_add.cpp;Add_UX_1W;2");
        if (w_buf.BLOCK_COUNT < 1)
            throw InternalErrorException(L"予期しないルートに到達しました。", L"pmc_add.cpp;Add_UX_1W;3");
#endif
        // 最下桁の加算を行う
        __CARRY_T c = _ADD_UNIT(0, u_buf.BLOCK[0], v, &w_buf.BLOCK[0]);

        // 残りの桁の繰上りを行い復帰する。
        return (ep.Carry(c, u_buf.Region(1), w_buf.Region(1)));
    }

    static __CARRY_T Add_UX_2W(BasicOperatorEngine& ep, _UBASIC_T& u_buf, __UNIT_TYPE v_hi, __UNIT_TYPE v_lo)
    {
#ifdef _DEBUG
        if (u_buf.BLOCK_COUNT < 2)
            throw InternalErrorException(L"予期しないルートに到達しました。", L"pmc_add.cpp;Add_UX_2W;1");
#endif
        // 最下位のワードの加算をする
        __CARRY_T c = _ADD_UNIT(0, u_buf.BLOCK[0], v_lo, &u_buf.BLOCK[0]);

        // 最下位から 2 番目のワードの加算をする。
        c = _ADD_UNIT(c, u_buf.BLOCK[1], v_hi, &u_buf.BLOCK[1]);

        // 残りの桁の繰り上がりを計算し、復帰する。
        return (ep.Carry(c, u_buf.Region(2)));
    }

    static __CARRY_T Add_UX_2W(BasicOperatorEngine& ep, _UBASIC_T u_buf, __UNIT_TYPE v_hi, __UNIT_TYPE v_lo, _UBASIC_T& w_buf)
    {
#ifdef _DEBUG
        if (u_buf.BLOCK_COUNT < 1)
            throw InternalErrorException(L"予期しないルートに到達しました。", L"pmc_add.cpp;Add_UX_2W;1");
        if (w_buf.BLOCK_COUNT < u_buf.BLOCK_COUNT + 1)
            throw InternalErrorException(L"予期しないルートに到達しました。", L"pmc_add.cpp;Add_UX_2W;2");
        if (w_buf.BLOCK_COUNT < 2)
            throw InternalErrorException(L"予期しないルートに到達しました。", L"pmc_add.cpp;Add_UX_2W;3");
#endif
        if (u_buf.BLOCK_COUNT < 2)
        {
            // u が 1 ワードしかなかった場合

            // 最下位ワードの加算を行う
            __CARRY_T c = _ADD_UNIT(0, u_buf.BLOCK[0], v_lo, &w_buf.BLOCK[0]);

            // 最下位から 2 番目のワードの加算を行う
            c = _ADD_UNIT(c, 0, v_hi, &w_buf.BLOCK[1]);

            if (!c)
            {
                // 桁上りが発生しなかった場合
                w_buf.Region(2).Clear();
                return (0);
            }
            else if (w_buf.BLOCK_COUNT >= 3)
            {
                // 桁上りが発生し、かつ w_buf に桁上りを格納する余地がある場合
                w_buf.BLOCK[2] = 1;
                w_buf.Region(3).Clear();
                return (0);
            }
            else
            {
                // 桁上りが発生し、かつ w_buf に桁上りを格納できない場合
                return (1);
            }
        }
        else
        {
            // u が 2 ワード以上あった場合

            // 最下位のワードの加算をする
            __CARRY_T c = _ADD_UNIT(0, u_buf.BLOCK[0], v_lo, &w_buf.BLOCK[0]);

            // 最下位から 2 番目のワードの加算をする。
            c = _ADD_UNIT(c, u_buf.BLOCK[1], v_hi, &w_buf.BLOCK[1]);

            // 残りの桁の繰り上がりを計算し、復帰する。
            return (ep.Carry(c, u_buf.Region(2), w_buf.Region(2)));
        }
    }

    static __CARRY_T Add_Imp(BasicOperatorEngine& ep, _UBASIC_T& u_buf, _UBASIC_T v_buf)
    {
#ifdef _DEBUG
        if (u_buf.BLOCK_COUNT < v_buf.BLOCK_COUNT)
            throw InternalErrorException(L"予期しないルートに到達しました。", L"pmc_add.cpp;Add_Imp;1");
#endif

        __UNIT_TYPE* up = u_buf.BLOCK;
        __UNIT_TYPE* vp = v_buf.BLOCK;
        __UNIT_TYPE v_count = v_buf.BLOCK_COUNT;
        __CARRY_T c = 0;

        // まず 32 ワードずつ加算をする。
        __UNIT_TYPE count = v_count >> 5;
        while (count != 0)
        {
            c = _ADD_32WORDS_ADC(c, up, vp, up);
            up += 32;
            vp += 32;
            --count;
        }
        // この時点で未処理の桁は 32 ワード未満のはず

        // 未処理の桁が 16 ワード以上あるなら 16 ワード加算を行う。
        if (v_count & 0x10)
        {
            c = _ADD_16WORDS_ADC(c, up, vp, up);
            up += 16;
            vp += 16;
        }
        // この時点で未処理の桁は 16 ワード未満のはず

        // 未処理の桁が 8 ワード以上あるなら 8 ワード加算を行う。
        if (v_count & 0x8)
        {
            c = _ADD_8WORDS_ADC(c, up, vp, up);
            up += 8;
            vp += 8;
        }
        // この時点で未処理の桁は 8 ワード未満のはず

        // 未処理の桁が 4 ワード以上あるなら 4 ワード加算を行う。
        if (v_count & 0x4)
        {
            c = _ADD_4WORDS_ADC(c, up, vp, up);
            up += 4;
            vp += 4;
        }
        // この時点で未処理の桁は 4 ワード未満のはず

        // 未処理の桁が 2 ワード以上あるなら 2 ワード加算を行う。
        if (v_count & 0x2)
        {
            c = _ADD_2WORDS_ADC(c, up, vp, up);
            up += 2;
            vp += 2;
        }
        // この時点で未処理の桁は 2 ワード未満のはず

        // 未処理の桁が 1 ワード以上あるなら 1 ワード加算を行う。
        if (v_count & 0x1)
        {
            c = _ADD_UNIT(c, *up, *vp, up);
            up += 1;
            vp += 1;
        }

        // 残りの桁の繰り上がりを計算し、復帰する。
        return (ep.Carry(c, u_buf.Region(v_count)));
    }

    static __CARRY_T Add_Imp(BasicOperatorEngine& ep, _UBASIC_T u_buf, _UBASIC_T v_buf, _UBASIC_T& w_buf)
    {
#ifdef _DEBUG
        if (u_buf.BLOCK_COUNT < v_buf.BLOCK_COUNT)
            throw InternalErrorException(L"予期しないルートに到達しました。", L"pmc_add.cpp;Add_Imp;1");
        if (w_buf.BLOCK_COUNT < u_buf.BLOCK_COUNT)
            throw InternalErrorException(L"予期しないルートに到達しました。", L"pmc_add.cpp;Add_Imp;2");
#endif

        __UNIT_TYPE* up = u_buf.BLOCK;
        __UNIT_TYPE* vp = v_buf.BLOCK;
        __UNIT_TYPE* wp = w_buf.BLOCK;
        __UNIT_TYPE v_count = v_buf.BLOCK_COUNT;
        __CARRY_T c = 0;

        // まず 32 ワードずつ加算をする。
        __UNIT_TYPE count = v_count >> 5;
        while (count != 0)
        {
            c = _ADD_32WORDS_ADC(c, up, vp, wp);
            up += 32;
            vp += 32;
            wp += 32;
            --count;
        }
        // この時点で未処理の桁は 32 ワード未満のはず

        // 未処理の桁が 16 ワード以上あるなら 16 ワード加算を行う。
        if (v_count & 0x10)
        {
            c = _ADD_16WORDS_ADC(c, up, vp, wp);
            up += 16;
            vp += 16;
            wp += 16;
        }
        // この時点で未処理の桁は 16 ワード未満のはず

        // 未処理の桁が 8 ワード以上あるなら 8 ワード加算を行う。
        if (v_count & 0x8)
        {
            c = _ADD_8WORDS_ADC(c, up, vp, wp);
            up += 8;
            vp += 8;
            wp += 8;
        }
        // この時点で未処理の桁は 8 ワード未満のはず

        // 未処理の桁が 4 ワード以上あるなら 4 ワード加算を行う。
        if (v_count & 0x4)
        {
            c = _ADD_4WORDS_ADC(c, up, vp, wp);
            up += 4;
            vp += 4;
            wp += 4;
        }
        // この時点で未処理の桁は 4 ワード未満のはず

        // 未処理の桁が 2 ワード以上あるなら 2 ワード加算を行う。
        if (v_count & 0x2)
        {
            c = _ADD_2WORDS_ADC(c, up, vp, wp);
            up += 2;
            vp += 2;
            wp += 2;
        }
        // この時点で未処理の桁は 2 ワード未満のはず

        // 未処理の桁が 1 ワード以上あるなら 1 ワード加算を行う。
        if (v_count & 0x1)
            c = _ADD_UNIT(c, *up++, *vp++, wp++);

        // 残りの桁の繰り上がりを計算し、復帰する。
        return (ep.Carry(c, u_buf.Region(v_count), w_buf.Region(v_count)));
    }

    __CARRY_T BasicOperatorEngine::Add(_UBASIC_T u_buf, _UBASIC_T v_buf)
    {
#ifdef _DEBUG
        if (v_buf.BLOCK_COUNT > 0 && v_buf.BLOCK[v_buf.BLOCK_COUNT - 1] == 0)
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_add.cpp;BasicOperatorEngine::Add;2");
#endif
        if (v_buf.BLOCK_COUNT == 0)
            return (0);
        else if (v_buf.BLOCK_COUNT == 1)
            return (Add_UX_1W(*this, u_buf, v_buf.BLOCK[0]));
        else if (v_buf.BLOCK_COUNT == 2)
            return (Add_UX_2W(*this, u_buf, v_buf.BLOCK[1], v_buf.BLOCK[0]));
        else
            return (Add_Imp(*this, u_buf, v_buf));
    }

    __CARRY_T BasicOperatorEngine::Add(_UBASIC_T u_buf, __UNIT_TYPE v, _UBASIC_T w_buf)
    {
#ifdef _DEBUG
        if (u_buf.BLOCK_COUNT > 0 && u_buf.BLOCK[u_buf.BLOCK_COUNT - 1] == 0)
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_add.cpp;BasicOperatorEngine::Add;1");
#endif
        if (v == 0)
        {
            w_buf.CopyFrom(u_buf);
            return (0);
        }
        else
            return (Add_UX_1W(*this, u_buf, v, w_buf));
    }

    __CARRY_T BasicOperatorEngine::Add(_UBASIC_T u_buf, __UNIT_TYPE v_hi, __UNIT_TYPE v_lo, _UBASIC_T w_buf)
    {
#ifdef _DEBUG
        if (u_buf.BLOCK_COUNT > 0 && u_buf.BLOCK[u_buf.BLOCK_COUNT - 1] == 0)
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_add.cpp;BasicOperatorEngine::Add;1");
#endif
        if (v_hi == 0)
            return (Add(u_buf, v_lo, w_buf));
        else
            return (Add_UX_2W(*this, u_buf, v_hi, v_lo, w_buf));
    }

    __CARRY_T BasicOperatorEngine::Add(_UBASIC_T u_buf, _UBASIC_T v_buf, _UBASIC_T w_buf)
    {
#ifdef _DEBUG
        if (u_buf.BLOCK_COUNT > 0 && u_buf.BLOCK[u_buf.BLOCK_COUNT - 1] == 0)
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_add.cpp;BasicOperatorEngine::Add;1");
        if (v_buf.BLOCK_COUNT > 0 && v_buf.BLOCK[v_buf.BLOCK_COUNT - 1] == 0)
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_add.cpp;BasicOperatorEngine::Add;2");
#endif
        if (u_buf.BLOCK_COUNT < v_buf.BLOCK_COUNT)
            return (Add(v_buf, u_buf, w_buf));
        else
        {
            if (v_buf.BLOCK_COUNT == 0)
            {
                w_buf.CopyFrom(u_buf);
                return (0);
            }
            else
                return (Add_Imp(*this, u_buf, v_buf, w_buf));
        }
    }

}


/*
 * END OF FILE
 */