/*
 * The MIT License
 *
 * Copyright 2019 Palmtree Software.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#pragma once

#ifndef PMC_BASIC_H
#define PMC_BASIC_H

#include "pmc_uint_internal.h"
#include "pmc_autogenerated_inline_func.h"

#ifdef _M_IX86
#define INVERSE_3_MOD_UNIT_TYPE (2863311531U)
#elif defined(_M_X64)
#define INVERSE_3_MOD_UNIT_TYPE (12297829382473034411U)
#else
#error unknown platform
#endif

namespace Palmtree::Math::Core::Internal::Basic
{

    __inline static __UNIT_TYPE __Shrink(__UNIT_TYPE* buf, __UNIT_TYPE count)
    {
        while (count > 0 && buf[count - 1] == 0)
            --count;
        return (count);
    }

    // u_buf += c
    __inline static __CARRY_T Carry(__CARRY_T c, __UNIT_TYPE* u_buf, __UNIT_TYPE u_buf_count)
    {
        while (c && u_buf_count > 0)
        {
            c = _ADD_UNIT(c, *u_buf, 0, u_buf);
            ++u_buf;
            --u_buf_count;
        }
        return (c);
    }

    // w_buf = u_buf + c;
    __inline static  __CARRY_T Carry(__CARRY_T c, __UNIT_TYPE* u_buf, __UNIT_TYPE u_buf_count, __UNIT_TYPE* w_buf, __UNIT_TYPE w_buf_count)
    {
#ifdef _DEBUG
        if (u_buf_count > w_buf_count)
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic.h;Carry;1");
#endif

        while (c && u_buf_count > 0)
        {
            c = _ADD_UNIT(c, *u_buf, 0, w_buf);
            ++u_buf;
            ++w_buf;
            --u_buf_count;
            --w_buf_count;
        }
        if (u_buf_count > 0)
        {
            _COPY_MEMORY_UNIT(w_buf, u_buf, u_buf_count);
            u_buf += u_buf_count;
            w_buf += u_buf_count;
            w_buf_count -= u_buf_count;
            u_buf_count = 0;
        }
        if (c && w_buf_count > 0)
        {
            *w_buf = 1;
            w_buf += 1;
            w_buf_count -= 1;
            c = 0;
        }
        _ZERO_MEMORY_UNIT(w_buf, w_buf_count);
        return (c);
    }

    // u_buf += v_buf;
    __inline static __CARRY_T Add(__UNIT_TYPE* u_buf, __UNIT_TYPE u_buf_count, __UNIT_TYPE* v_buf, __UNIT_TYPE v_buf_count)
    {
#ifdef _DEBUG
        if (u_buf_count < v_buf_count)
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic.h;Add;1");
#endif

        __UNIT_TYPE* up = u_buf;
        __UNIT_TYPE* vp = v_buf;
        __CARRY_T c = 0;

        // まず 32 ワードずつ加算をする。
        __UNIT_TYPE count = v_buf_count >> 5;
        while (count != 0)
        {
            c = _ADD_32WORDS_ADC(c, up, vp, up);
            up += 32;
            vp += 32;
            --count;
        }
        // この時点で未処理の桁は 32 ワード未満のはず

        // 未処理の桁が 16 ワード以上あるなら 16 ワード加算を行う。
        if (v_buf_count & 0x10)
        {
            c = _ADD_16WORDS_ADC(c, up, vp, up);
            up += 16;
            vp += 16;
        }
        // この時点で未処理の桁は 16 ワード未満のはず

        // 未処理の桁が 8 ワード以上あるなら 8 ワード加算を行う。
        if (v_buf_count & 0x8)
        {
            c = _ADD_8WORDS_ADC(c, up, vp, up);
            up += 8;
            vp += 8;
        }
        // この時点で未処理の桁は 8 ワード未満のはず

        // 未処理の桁が 4 ワード以上あるなら 4 ワード加算を行う。
        if (v_buf_count & 0x4)
        {
            c = _ADD_4WORDS_ADC(c, up, vp, up);
            up += 4;
            vp += 4;
        }
        // この時点で未処理の桁は 4 ワード未満のはず

        // 未処理の桁が 2 ワード以上あるなら 2 ワード加算を行う。
        if (v_buf_count & 0x2)
        {
            c = _ADD_2WORDS_ADC(c, up, vp, up);
            up += 2;
            vp += 2;
        }
        // この時点で未処理の桁は 2 ワード未満のはず

        // 未処理の桁が 1 ワード以上あるなら 1 ワード加算を行う。
        if (v_buf_count & 0x1)
        {
            c = _ADD_UNIT(c, *up, *vp, up);
            up += 1;
            vp += 1;
        }

        // 残りの桁の繰り上がりを計算し、復帰する。
        return (Carry(c, u_buf + v_buf_count, u_buf_count - v_buf_count));
    }

    // w_buf = u_buf + v;
    __inline static __CARRY_T Add(__UNIT_TYPE* u_buf, __UNIT_TYPE u_buf_count, __UNIT_TYPE v, __UNIT_TYPE* w_buf, __UNIT_TYPE w_buf_count)
    {
#ifdef _DEBUG
        if (u_buf_count > 0 && u_buf[u_buf_count - 1] == 0)
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic.h;Add;1");
        if (u_buf_count < 1)
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic.h;Add;2");
        if (w_buf_count < u_buf_count + 1)
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic.h;Add;3");
        if (w_buf_count < 1)
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic.h;Add;4");
#endif
        if (v == 0)
        {
            _COPY_MEMORY_UNIT(w_buf, u_buf, u_buf_count);
            _ZERO_MEMORY_UNIT(w_buf + u_buf_count, w_buf_count - u_buf_count);
            return (0);
        }
        else
        {
            // 最下桁の加算を行う
            __CARRY_T c = _ADD_UNIT(0, u_buf[0], v, &w_buf[0]);

            // 残りの桁の繰上りを行い復帰する。
            return (Carry(c, u_buf + 1, u_buf_count - 1, w_buf + 1, w_buf_count - 1));
        }
    }

    // w_buf = u_buf + v;
    __inline static __CARRY_T Add(__UNIT_TYPE* u_buf, __UNIT_TYPE u_buf_count, __UNIT_TYPE v_hi, __UNIT_TYPE v_lo, __UNIT_TYPE* w_buf, __UNIT_TYPE w_buf_count)
    {
#ifdef _DEBUG
        if (u_buf_count > 0 && u_buf[u_buf_count - 1] == 0)
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic.h;Add;1");
        if (u_buf_count < 1)
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic.h;Add;2");
        if (w_buf_count < u_buf_count + 1)
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic.h;Add;3");
        if (w_buf_count < 2)
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic.h;Add;4");
#endif
        if (v_hi == 0)
            return (Add(u_buf, u_buf_count, v_lo, w_buf, w_buf_count));
        else
        {
            if (u_buf_count < 2)
            {
                // u が 1 ワードしかなかった場合

                // 最下位ワードの加算を行う
                __CARRY_T c = _ADD_UNIT(0, u_buf[0], v_lo, &w_buf[0]);

                // 最下位から 2 番目のワードの加算を行う
                c = _ADD_UNIT(c, 0, v_hi, &w_buf[1]);

                if (!c)
                {
                    // 桁上りが発生しなかった場合
                    _ZERO_MEMORY_UNIT(w_buf + 2, w_buf_count - 2);
                    return (0);
                }
                else if (w_buf_count >= 3)
                {
                    // 桁上りが発生し、かつ w_buf に桁上りを格納する余地がある場合
                    w_buf[2] = 1;
                    _ZERO_MEMORY_UNIT(w_buf + 3, w_buf_count - 3);
                    return (0);
                }
                else
                {
                    // 桁上りが発生し、かつ w_buf に桁上りを格納できない場合
                    return (1);
                }
            }
            else
            {
                // u が 2 ワード以上あった場合

                // 最下位のワードの加算をする
                __CARRY_T c = _ADD_UNIT(0, u_buf[0], v_lo, &w_buf[0]);

                // 最下位から 2 番目のワードの加算をする。
                c = _ADD_UNIT(c, u_buf[1], v_hi, &w_buf[1]);

                // 残りの桁の繰り上がりを計算し、復帰する。
                return (Carry(c, u_buf + 2, u_buf_count - 2, w_buf + 2, w_buf_count - 2));
            }
        }
    }

    __inline static __CARRY_T __Add(__UNIT_TYPE* u_buf, __UNIT_TYPE u_buf_count, __UNIT_TYPE* v_buf, __UNIT_TYPE v_buf_count, __UNIT_TYPE* w_buf, __UNIT_TYPE w_buf_count)
    {
#ifdef _DEBUG
        if (u_buf_count < v_buf_count)
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic.h;Add;1");
        if (w_buf_count < u_buf_count)
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic.h;Add;1");
#endif

        __UNIT_TYPE* up = u_buf;
        __UNIT_TYPE* vp = v_buf;
        __UNIT_TYPE* wp = w_buf;
        __CARRY_T c = 0;

        // まず 32 ワードずつ加算をする。
        __UNIT_TYPE count = v_buf_count >> 5;
        while (count != 0)
        {
            c = _ADD_32WORDS_ADC(c, up, vp, wp);
            up += 32;
            vp += 32;
            wp += 32;
            --count;
        }
        // この時点で未処理の桁は 32 ワード未満のはず

        // 未処理の桁が 16 ワード以上あるなら 16 ワード加算を行う。
        if (v_buf_count & 0x10)
        {
            c = _ADD_16WORDS_ADC(c, up, vp, wp);
            up += 16;
            vp += 16;
            wp += 16;
        }
        // この時点で未処理の桁は 16 ワード未満のはず

        // 未処理の桁が 8 ワード以上あるなら 8 ワード加算を行う。
        if (v_buf_count & 0x8)
        {
            c = _ADD_8WORDS_ADC(c, up, vp, wp);
            up += 8;
            vp += 8;
            wp += 8;
        }
        // この時点で未処理の桁は 8 ワード未満のはず

        // 未処理の桁が 4 ワード以上あるなら 4 ワード加算を行う。
        if (v_buf_count & 0x4)
        {
            c = _ADD_4WORDS_ADC(c, up, vp, wp);
            up += 4;
            vp += 4;
            wp += 4;
        }
        // この時点で未処理の桁は 4 ワード未満のはず

        // 未処理の桁が 2 ワード以上あるなら 2 ワード加算を行う。
        if (v_buf_count & 0x2)
        {
            c = _ADD_2WORDS_ADC(c, up, vp, wp);
            up += 2;
            vp += 2;
            wp += 2;
        }
        // この時点で未処理の桁は 2 ワード未満のはず

        // 未処理の桁が 1 ワード以上あるなら 1 ワード加算を行う。
        if (v_buf_count & 0x1)
            c = _ADD_UNIT(c, *up++, *vp++, wp++);

        // 残りの桁の繰り上がりを計算し、復帰する。
        return (Carry(c, u_buf + v_buf_count, u_buf_count - v_buf_count, w_buf + v_buf_count, w_buf_count - v_buf_count));
    }

    // w_buf = u_buf + v_buf;
    __inline static __CARRY_T Add(__UNIT_TYPE* u_buf, __UNIT_TYPE u_buf_count, __UNIT_TYPE* v_buf, __UNIT_TYPE v_buf_count, __UNIT_TYPE* w_buf, __UNIT_TYPE w_buf_count)
    {
#ifdef _DEBUG
        if (u_buf_count > 0 && u_buf[u_buf_count - 1] == 0)
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic.h;Add;1");
        if (v_buf_count > 0 && v_buf[v_buf_count - 1] == 0)
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic.h;Add;2");
#endif
        if (v_buf_count == 0)
        {
            _COPY_MEMORY_UNIT(w_buf, u_buf, u_buf_count);
            _ZERO_MEMORY_UNIT(w_buf + u_buf_count, w_buf_count - u_buf_count);
            return (0);
        }
        else
        {
            if (u_buf_count >= v_buf_count)
                return (__Add(u_buf, u_buf_count, v_buf, v_buf_count, w_buf, w_buf_count));
            else
                return (__Add(v_buf, v_buf_count, u_buf, u_buf_count, w_buf, w_buf_count));
        }
    }

    // u_buf -= c
    __inline static __BORROW_T Borrow(__BORROW_T c, __UNIT_TYPE* u_buf, __UNIT_TYPE u_buf_count)
    {
        while (c && u_buf_count > 0)
        {
            c = _SUBTRUCT_UNIT(c, *u_buf, 0, u_buf);
            ++u_buf;
            --u_buf_count;
        }
        return (u_buf_count > 0 ? 0 : c);
    }

    // w_buf = - u_buf - c;
    __inline static __BORROW_T Borrow(__BORROW_T c, __UNIT_TYPE* u_buf, __UNIT_TYPE u_buf_count, __UNIT_TYPE* w_buf, __UNIT_TYPE w_buf_count)
    {
#ifdef _DEBUG
        if (u_buf_count > w_buf_count)
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic.h;Borrow;1");
#endif

        while (c && u_buf_count > 0)
        {
            c = _SUBTRUCT_UNIT(c, *u_buf, 0, w_buf);
            ++u_buf;
            ++w_buf;
            --u_buf_count;
            --w_buf_count;
        }
        if (u_buf_count > 0)
        {
            _COPY_MEMORY_UNIT(w_buf, u_buf, u_buf_count);
            u_buf += u_buf_count;
            w_buf += u_buf_count;
            w_buf_count -= u_buf_count;
            u_buf_count = 0;
        }
        if (w_buf_count > 0)
        {
            if (c)
                _FILL_MEMORY_UNIT(w_buf, (__UNIT_TYPE)-1, w_buf_count);
            else
                _ZERO_MEMORY_UNIT(w_buf, w_buf_count);
        }
        return (c);
    }

    // u_buf -= v_buf;
    __inline static void USubtruct(__UNIT_TYPE* u_buf, __UNIT_TYPE u_buf_count, __UNIT_TYPE* v_buf, __UNIT_TYPE v_buf_count)
    {
#ifdef _DEBUG
        if (v_buf_count > 0 && v_buf[v_buf_count - 1] == 0)
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic.h;USubtruct;1");
        if (u_buf_count < v_buf_count)
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic.h;USubtruct;2");
#endif
        if (v_buf_count == 0)
        {
            // nop
        }
        else
        {
            __UNIT_TYPE* up = u_buf;
            __UNIT_TYPE* vp = v_buf;
            __BORROW_T c = 0;

            // まず 32 ワードずつ減算をする。
            __UNIT_TYPE count = v_buf_count >> 5;
            while (count != 0)
            {
                c = _SUBTRUCT_32WORDS_SBB(c, up, vp, up);
                up += 32;
                vp += 32;
                --count;
            }
            // この時点で未処理の桁は 32 ワード未満のはず

            // 未処理の桁が 16 ワード以上あるなら 16 ワード減算を行う。
            if (v_buf_count & 0x10)
            {
                c = _SUBTRUCT_16WORDS_SBB(c, up, vp, up);
                up += 16;
                vp += 16;
            }
            // この時点で未処理の桁は 16 ワード未満のはず

            // 未処理の桁が 8 ワード以上あるなら 8 ワード減算を行う。
            if (v_buf_count & 0x8)
            {
                c = _SUBTRUCT_8WORDS_SBB(c, up, vp, up);
                up += 8;
                vp += 8;
            }
            // この時点で未処理の桁は 8 ワード未満のはず

            // 未処理の桁が 4 ワード以上あるなら 4 ワード減算を行う。
            if (v_buf_count & 0x4)
            {
                c = _SUBTRUCT_4WORDS_SBB(c, up, vp, up);
                up += 4;
                vp += 4;
            }
            // この時点で未処理の桁は 4 ワード未満のはず

            // 未処理の桁が 2 ワード以上あるなら 2 ワード減算を行う。
            if (v_buf_count & 0x2)
            {
                c = _SUBTRUCT_2WORDS_SBB(c, up, vp, up);
                up += 2;
                vp += 2;
            }
            // この時点で未処理の桁は 2 ワード未満のはず

            // 未処理の桁が 1 ワード以上あるなら 1 ワード減算を行う。
            if (v_buf_count & 1)
            {
                c = _SUBTRUCT_UNIT(c, *up, *vp, up);
                up += 1;
                vp += 1;
            }

            // 残りの桁の繰り上がりを計算し、復帰する。
            if (Borrow(c, u_buf + v_buf_count, u_buf_count - v_buf_count))
                throw OverflowException(L"減算によりオーバーフローが発生しました。");
        }
    }

    // w_buf = u_buf - v;
    __inline static void USubtruct(__UNIT_TYPE* u_buf, __UNIT_TYPE u_buf_count, __UNIT_TYPE v, __UNIT_TYPE* w_buf, __UNIT_TYPE w_buf_count)
    {
#ifdef _DEBUG
        if (u_buf_count > 0 && u_buf[u_buf_count - 1] == 0)
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic.h;USubtruct;1");
        if (w_buf_count < u_buf_count)
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic.h;USubtruct;2");
        if (w_buf_count < 1)
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic.h;USubtruct;3");
#endif
        if (v == 0)
        {
            _COPY_MEMORY_UNIT(w_buf, u_buf, u_buf_count);
            _ZERO_MEMORY_UNIT(w_buf + u_buf_count, w_buf_count - u_buf_count);
        }
        else if (u_buf_count < 1)
            throw OverflowException(L"減算によりオーバーフローが発生しました。");
        else
        {
            // 最下桁の減算を行う
            __BORROW_T c = _SUBTRUCT_UNIT(0, u_buf[0], v, &w_buf[0]);

            // 残りの桁の繰上りを行い復帰する。
            if (Borrow(c, u_buf + 1, u_buf_count - 1, w_buf + 1, w_buf_count - 1))
                throw OverflowException(L"減算によりオーバーフローが発生しました。");
        }
    }

    // w_buf = u_buf - v;
    __inline static void USubtruct(__UNIT_TYPE* u_buf, __UNIT_TYPE u_buf_count, __UNIT_TYPE v_hi, __UNIT_TYPE v_lo, __UNIT_TYPE* w_buf, __UNIT_TYPE w_buf_count)
    {
#ifdef _DEBUG
        if (u_buf_count > 0 && u_buf[u_buf_count - 1] == 0)
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic.h;USubtruct;1");
        if (w_buf_count < u_buf_count)
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic.h;USubtruct;2");
#endif
        if (v_hi == 0)
            USubtruct(u_buf, u_buf_count, v_lo, w_buf, w_buf_count);
        else if (u_buf_count < 2)
            throw OverflowException(L"減算によりオーバーフローが発生しました。");
        else
        {
            // x が 2 ワード以上あった場合

            // 最下位のワードの減算をする
            __BORROW_T c = _SUBTRUCT_UNIT(0, u_buf[0], v_lo, &w_buf[0]);

            // 最下位から 2 番目のワードの減算をする。
            c = _SUBTRUCT_UNIT(c, u_buf[1], v_hi, &w_buf[1]);

            // 残りの桁の繰り上がりを計算し、復帰する。
            if (Borrow(c, u_buf + 2, u_buf_count - 2, w_buf + 2, w_buf_count - 2))
                throw OverflowException(L"減算によりオーバーフローが発生しました。");
        }
    }

    // w = u - v_buf;
    __inline static void USubtruct(__UNIT_TYPE u, __UNIT_TYPE* v_buf, __UNIT_TYPE v_buf_count, __UNIT_TYPE& w)
    {
#ifdef _DEBUG
        if (v_buf_count > 0 && v_buf[v_buf_count - 1] == 0)
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic.h;USubtruct;1");
#endif
        if (v_buf_count == 0)
            w = u;
        else if (v_buf_count == 1)
        {
            __BORROW_T b = _SUBTRUCT_UNIT(0, u, v_buf[0], &w);
            if (b)
                throw OverflowException(L"減算によりオーバーフローが発生しました。");
        }
        else
            throw OverflowException(L"減算によりオーバーフローが発生しました。");
    }

    // w = u - v_buf;
    __inline static void USubtruct(__UNIT_TYPE u_hi, __UNIT_TYPE u_lo, __UNIT_TYPE* v_buf, __UNIT_TYPE v_buf_count, __UNIT_TYPE& w_hi, __UNIT_TYPE& w_lo)
    {
#ifdef _DEBUG
        if (v_buf_count > 0 && v_buf[v_buf_count - 1] == 0)
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic.h;USubtruct;1");
#endif
        if (u_hi == 0)
        {
            USubtruct(u_lo, v_buf, v_buf_count, w_lo);
            w_hi = 0;
        }
        else if (v_buf_count == 0)
        {
            w_lo = u_lo;
            w_hi = u_hi;
        }
        else if (v_buf_count == 1)
        {
            __BORROW_T b = _SUBTRUCT_UNIT(0, u_lo, v_buf[0], &w_lo);
            b = _SUBTRUCT_UNIT(b, u_hi, 0, &w_hi);
            if (b)
                throw OverflowException(L"減算によりオーバーフローが発生しました。");
        }
        else if (v_buf_count == 2)
        {
            __BORROW_T b = _SUBTRUCT_UNIT(0, u_lo, v_buf[0], &w_lo);
            b = _SUBTRUCT_UNIT(b, u_hi, v_buf[1], &w_hi);
            if (b)
                throw OverflowException(L"減算によりオーバーフローが発生しました。");
        }
        else
            throw OverflowException(L"減算によりオーバーフローが発生しました。");
    }

    __inline static void __USubtruct(__UNIT_TYPE* u_buf, __UNIT_TYPE u_buf_count, __UNIT_TYPE* v_buf, __UNIT_TYPE v_buf_count, __UNIT_TYPE* w_buf, __UNIT_TYPE w_buf_count)
    {
        __UNIT_TYPE* up = u_buf;
        __UNIT_TYPE* vp = v_buf;
        __UNIT_TYPE* wp = w_buf;
        __BORROW_T c = 0;

        // まず 32 ワードずつ減算をする。
        __UNIT_TYPE count = v_buf_count >> 5;
        while (count != 0)
        {
            c = _SUBTRUCT_32WORDS_SBB(c, up, vp, wp);
            up += 32;
            vp += 32;
            wp += 32;
            --count;
        }
        // この時点で未処理の桁は 32 ワード未満のはず

        // 未処理の桁が 16 ワード以上あるなら 16 ワード減算を行う。
        if (v_buf_count & 0x10)
        {
            c = _SUBTRUCT_16WORDS_SBB(c, up, vp, wp);
            up += 16;
            vp += 16;
            wp += 16;
        }
        // この時点で未処理の桁は 16 ワード未満のはず

        // 未処理の桁が 8 ワード以上あるなら 8 ワード減算を行う。
        if (v_buf_count & 0x8)
        {
            c = _SUBTRUCT_8WORDS_SBB(c, up, vp, wp);
            up += 8;
            vp += 8;
            wp += 8;
        }
        // この時点で未処理の桁は 8 ワード未満のはず

        // 未処理の桁が 4 ワード以上あるなら 4 ワード減算を行う。
        if (v_buf_count & 0x4)
        {
            c = _SUBTRUCT_4WORDS_SBB(c, up, vp, wp);
            up += 4;
            vp += 4;
            wp += 4;
        }
        // この時点で未処理の桁は 4 ワード未満のはず

        // 未処理の桁が 2 ワード以上あるなら 2 ワード減算を行う。
        if (v_buf_count & 0x2)
        {
            c = _SUBTRUCT_2WORDS_SBB(c, up, vp, wp);
            up += 2;
            vp += 2;
            wp += 2;
        }
        // この時点で未処理の桁は 2 ワード未満のはず

        // 未処理の桁が 1 ワード以上あるなら 1 ワード減算を行う。
        if (v_buf_count & 1)
            c = _SUBTRUCT_UNIT(c, *up++, *vp++, wp++);

        // 残りの桁の繰り上がりを計算し、復帰する。
        if (Borrow(c, u_buf + v_buf_count, u_buf_count - v_buf_count, w_buf + v_buf_count, w_buf_count - v_buf_count))
            throw OverflowException(L"減算によりオーバーフローが発生しました。");
    }

    // w_buf = u_buf - v_buf;
    __inline static void USubtruct(__UNIT_TYPE* u_buf, __UNIT_TYPE u_buf_count, __UNIT_TYPE* v_buf, __UNIT_TYPE v_buf_count, __UNIT_TYPE* w_buf, __UNIT_TYPE w_buf_count)
    {
#ifdef _DEBUG
        if (u_buf_count > 0 && u_buf[u_buf_count - 1] == 0)
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic.h;USubtruct;1");
        if (v_buf_count > 0 && v_buf[v_buf_count - 1] == 0)
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic.h;USubtruct;2");
        if (w_buf_count < u_buf_count)
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic.h;USubtruct;2");
#endif
        if (v_buf_count == 0)
        {
            _COPY_MEMORY_UNIT(w_buf, u_buf, u_buf_count);
            _ZERO_MEMORY_UNIT(w_buf + u_buf_count, w_buf_count - u_buf_count);
        }
        else if (u_buf_count < v_buf_count)
            throw OverflowException(L"減算によりオーバーフローが発生しました。");
        else
            __USubtruct(u_buf, u_buf_count, v_buf, v_buf_count, w_buf, w_buf_count);
    }

    // u_buf = v_buf - u_buf;
    __inline static void UNegativeSubtruct(__UNIT_TYPE* u_buf, __UNIT_TYPE u_buf_count, __UNIT_TYPE* v_buf, __UNIT_TYPE v_buf_count)
    {
#ifdef _DEBUG
        if (v_buf_count > 0 && v_buf[v_buf_count - 1] == 0)
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic.h;UNegativeSubtruct;1");
        if (u_buf_count < v_buf_count)
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic.h;UNegativeSubtruct;2");
#endif
        __UNIT_TYPE u_buf_count2 = __Shrink(u_buf, u_buf_count);
        if (u_buf_count2 == 0)
        {
            _COPY_MEMORY_UNIT(u_buf, v_buf, v_buf_count);
            _ZERO_MEMORY_UNIT(u_buf + v_buf_count, u_buf_count - v_buf_count);
        }
        else if (v_buf_count < u_buf_count2)
            throw OverflowException(L"減算によりオーバーフローが発生しました。");
        else
            __USubtruct(v_buf, v_buf_count, u_buf, u_buf_count2, u_buf, u_buf_count);
    }

    // w_buf = u_buf * v;
    extern void Multiply(__UNIT_TYPE* u_buf, __UNIT_TYPE u_buf_count, __UNIT_TYPE v, __UNIT_TYPE* w_buf, __UNIT_TYPE w_buf_count);

    // w_buf = u_buf * v;
    extern void Multiply(__UNIT_TYPE* u_buf, __UNIT_TYPE u_buf_count, __UNIT_TYPE v_hi, __UNIT_TYPE v_lo, __UNIT_TYPE* w_buf, __UNIT_TYPE w_buf_count);

    // w_buf = u_buf * v_buf;
    extern void Multiply(ThreadContext& tc, PMC_MULTIPLICATION_METHOD_CODE method, __UNIT_TYPE* u_buf, __UNIT_TYPE u_buf_count, __UNIT_TYPE* v_buf, __UNIT_TYPE v_buf_count, __UNIT_TYPE* w_buf, __UNIT_TYPE w_buf_count);

    namespace NDivRem
    {

        __inline static bool MultiplySubtructArray_UNIT(__UNIT_TYPE* u_buf, __UNIT_TYPE u_buf_count, __UNIT_TYPE* v_buf, __UNIT_TYPE v_buf_count, __UNIT_TYPE q_index, __UNIT_TYPE q_)
        {
            __UNIT_TYPE* u_ptr = &u_buf[q_index];
            __UNIT_TYPE* v_ptr = &v_buf[0];
            __UNIT_TYPE v_count = v_buf_count;
            __UNIT_TYPE k = 0;
            __BORROW_T c = 0;

            __UNIT_TYPE count = v_count >> 5;
            while (count != 0)
            {
                c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[0], q_, &u_ptr[0]);
                c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[1], q_, &u_ptr[1]);
                c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[2], q_, &u_ptr[2]);
                c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[3], q_, &u_ptr[3]);
                c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[4], q_, &u_ptr[4]);
                c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[5], q_, &u_ptr[5]);
                c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[6], q_, &u_ptr[6]);
                c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[7], q_, &u_ptr[7]);
                c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[8], q_, &u_ptr[8]);
                c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[9], q_, &u_ptr[9]);
                c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[10], q_, &u_ptr[10]);
                c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[11], q_, &u_ptr[11]);
                c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[12], q_, &u_ptr[12]);
                c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[13], q_, &u_ptr[13]);
                c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[14], q_, &u_ptr[14]);
                c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[15], q_, &u_ptr[15]);
                c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[16], q_, &u_ptr[16]);
                c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[17], q_, &u_ptr[17]);
                c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[18], q_, &u_ptr[18]);
                c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[19], q_, &u_ptr[19]);
                c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[20], q_, &u_ptr[20]);
                c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[21], q_, &u_ptr[21]);
                c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[22], q_, &u_ptr[22]);
                c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[23], q_, &u_ptr[23]);
                c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[24], q_, &u_ptr[24]);
                c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[25], q_, &u_ptr[25]);
                c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[26], q_, &u_ptr[26]);
                c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[27], q_, &u_ptr[27]);
                c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[28], q_, &u_ptr[28]);
                c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[29], q_, &u_ptr[29]);
                c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[30], q_, &u_ptr[30]);
                c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[31], q_, &u_ptr[31]);
                u_ptr += 32;
                v_ptr += 32;
                --count;
#ifdef ENABLED_PERFORMANCE_COUNTER
                if (sizeof(k) == sizeof(_UINT64_T))
                    AddToMULTI64Counter(32);
                else
                    AddToMULTI32Counter(32);
#endif
            }

            if (v_count & 0x10)
            {
                c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[0], q_, &u_ptr[0]);
                c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[1], q_, &u_ptr[1]);
                c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[2], q_, &u_ptr[2]);
                c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[3], q_, &u_ptr[3]);
                c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[4], q_, &u_ptr[4]);
                c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[5], q_, &u_ptr[5]);
                c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[6], q_, &u_ptr[6]);
                c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[7], q_, &u_ptr[7]);
                c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[8], q_, &u_ptr[8]);
                c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[9], q_, &u_ptr[9]);
                c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[10], q_, &u_ptr[10]);
                c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[11], q_, &u_ptr[11]);
                c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[12], q_, &u_ptr[12]);
                c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[13], q_, &u_ptr[13]);
                c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[14], q_, &u_ptr[14]);
                c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[15], q_, &u_ptr[15]);
                u_ptr += 16;
                v_ptr += 16;
#ifdef ENABLED_PERFORMANCE_COUNTER
                if (sizeof(k) == sizeof(_UINT64_T))
                    AddToMULTI64Counter(16);
                else
                    AddToMULTI32Counter(16);
#endif
            }

            if (v_count & 0x8)
            {
                c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[0], q_, &u_ptr[0]);
                c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[1], q_, &u_ptr[1]);
                c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[2], q_, &u_ptr[2]);
                c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[3], q_, &u_ptr[3]);
                c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[4], q_, &u_ptr[4]);
                c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[5], q_, &u_ptr[5]);
                c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[6], q_, &u_ptr[6]);
                c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[7], q_, &u_ptr[7]);
                u_ptr += 8;
                v_ptr += 8;
#ifdef ENABLED_PERFORMANCE_COUNTER
                if (sizeof(k) == sizeof(_UINT64_T))
                    AddToMULTI64Counter(8);
                else
                    AddToMULTI32Counter(8);
#endif
            }

            if (v_count & 0x4)
            {
                c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[0], q_, &u_ptr[0]);
                c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[1], q_, &u_ptr[1]);
                c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[2], q_, &u_ptr[2]);
                c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[3], q_, &u_ptr[3]);
                u_ptr += 4;
                v_ptr += 4;
#ifdef ENABLED_PERFORMANCE_COUNTER
                if (sizeof(k) == sizeof(_UINT64_T))
                    AddToMULTI64Counter(4);
                else
                    AddToMULTI32Counter(4);
#endif
            }

            if (v_count & 0x2)
            {
                c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[0], q_, &u_ptr[0]);
                c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[1], q_, &u_ptr[1]);
                u_ptr += 2;
                v_ptr += 2;
#ifdef ENABLED_PERFORMANCE_COUNTER
                if (sizeof(k) == sizeof(_UINT64_T))
                    AddToMULTI64Counter(2);
                else
                    AddToMULTI32Counter(2);
#endif
            }

            if (v_count & 0x1)
            {
                c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[0], q_, &u_ptr[0]);
                u_ptr += 1;
                v_ptr += 1;
#ifdef ENABLED_PERFORMANCE_COUNTER
                if (sizeof(k) == sizeof(_UINT64_T))
                    IncrementMULTI64Counter();
                else
                    IncrementMULTI32Counter();
#endif
            }

            c = _SUBTRUCT_UNIT(c, *u_ptr, k, u_ptr);
            u_ptr += 1;

            return (Borrow(c, u_ptr, u_buf + u_buf_count - u_ptr));
        }

    }

    // q_buf = u_buf / v, r = u_buf % v;
    extern void DivRem(__UNIT_TYPE* u_buf, __UNIT_TYPE u_buf_count, __UNIT_TYPE v, __UNIT_TYPE* q_buf, __UNIT_TYPE q_buf_count, __UNIT_TYPE& r);

    // q = u / v_buf, r = u % v_buf;
    extern void DivRem(__UNIT_TYPE u, __UNIT_TYPE* v_buf, __UNIT_TYPE v_buf_count, __UNIT_TYPE& q, __UNIT_TYPE& r);

    // q_buf = u_buf / v_buf, u_buf %= v_buf (v_buf の最上位bitは 1 でなければならない)
    extern void DivRem(__UNIT_TYPE* u_buf, __UNIT_TYPE u_buf_count, __UNIT_TYPE* v_buf, __UNIT_TYPE v_buf_count, __UNIT_TYPE* q_buf, __UNIT_TYPE q_buf_count);
        
    // q_buf = u_buf / v_buf, r_buf = u_buf % v_buf;
    extern void DivRem(__UNIT_TYPE* u_buf, __UNIT_TYPE u_buf_count, __UNIT_TYPE* v_buf, __UNIT_TYPE v_buf_count, __UNIT_TYPE* work_v_buf, __UNIT_TYPE work_v_buf_count, __UNIT_TYPE* q_buf, __UNIT_TYPE q_buf_count, __UNIT_TYPE* r_buf, __UNIT_TYPE r_buf_count);

    // r = u_buf % v;
    extern void Remainder(__UNIT_TYPE* u_buf, __UNIT_TYPE u_buf_count, __UNIT_TYPE v, __UNIT_TYPE& r);

    // r = u % v_buf;
    extern void Remainder(__UNIT_TYPE u, __UNIT_TYPE* v_buf, __UNIT_TYPE v_buf_count, __UNIT_TYPE& r);

    // u_buf %= v_buf (v_buf の最上位bitは 1 でなければならない)
    extern void Remainder(__UNIT_TYPE* u_buf, __UNIT_TYPE u_buf_count, __UNIT_TYPE* v_buf, __UNIT_TYPE v_buf_count);

    // v_buf, r_buf = u_buf % v_buf;
    extern void Remainder(__UNIT_TYPE* u_buf, __UNIT_TYPE u_buf_count, __UNIT_TYPE* v_buf, __UNIT_TYPE v_buf_count, __UNIT_TYPE* work_v_buf, __UNIT_TYPE work_v_buf_count, __UNIT_TYPE* r_buf, __UNIT_TYPE r_buf_count);

    // returns u_buf == v;
    __inline static bool Equals(__UNIT_TYPE* u_buf, __UNIT_TYPE u_buf_count, __UNIT_TYPE v)
    {
#ifdef _DEBUG
        if (u_buf_count > 0 && u_buf[u_buf_count - 1] == 0)
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic.h;Equals;1");
#endif
        if (v == 0)
            return (u_buf_count == 0);
        else if (u_buf_count != 1)
            return (false);
        else
            return (u_buf[0] == v);
    }

    // returns u_buf == v;
    __inline static bool Equals(__UNIT_TYPE* u_buf, __UNIT_TYPE u_buf_count, __UNIT_TYPE v_hi, __UNIT_TYPE v_lo)
    {
#ifdef _DEBUG
        if (u_buf_count > 0 && u_buf[u_buf_count - 1] == 0)
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic.h;Equals;1");
#endif
        if (v_hi == 0)
            return (Equals(u_buf, u_buf_count, v_lo));
        else if (u_buf_count != 2)
            return (false);
        else
            return (u_buf[1] == v_hi && u_buf[0] == v_lo);
    }

    // returns u_buf == v_buf;
    __inline static bool Equals(__UNIT_TYPE* u_buf, __UNIT_TYPE u_buf_count, __UNIT_TYPE* v_buf, __UNIT_TYPE v_buf_count)
    {
#ifdef _DEBUG
        if (u_buf_count > 0 && u_buf[u_buf_count - 1] == 0)
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic.h;Equals;1");
        if (v_buf_count > 0 && v_buf[v_buf_count - 1] == 0)
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic.h;Equals;2");
#endif
        if (v_buf_count == 0)
            return (u_buf_count == 0);
        else if (u_buf_count != v_buf_count)
            return (false);
        else
        {
            __UNIT_TYPE* u_ptr = u_buf;
            __UNIT_TYPE* v_ptr = v_buf;
            __UNIT_TYPE count = u_buf_count;
            while (count > 0)
            {
                if (*u_ptr != *v_ptr)
                    return (false);
                ++u_ptr;
                ++v_ptr;
                --count;
            }
            return (true);
        }
    }

    __inline static SIGN_T __CompareWord(__UNIT_TYPE u, __UNIT_TYPE v)
    {
        if (u == v)
            return (SIGN_ZERO);
        else if (u > v)
            return (SIGN_POSITIVE);
        else
            return (SIGN_NEGATIVE);
    }

    // returns u_buf > v ? 1 : u_buf < v ? -1 : 0;
    __inline static SIGN_T Compare(__UNIT_TYPE* u_buf, __UNIT_TYPE u_buf_count, __UNIT_TYPE v)
    {
#ifdef _DEBUG
        if (u_buf_count > 0 && u_buf[u_buf_count - 1] == 0)
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic.h;Compare;1");
#endif
        if (u_buf_count == 0)
            return (v == 0 ? SIGN_ZERO : SIGN_NEGATIVE);
        else if (v == 0)
            return (SIGN_POSITIVE);
        else if (u_buf_count == 1)
            return (__CompareWord(u_buf[0], v));
        else
            return (SIGN_POSITIVE);
    }

    // returns u_buf > v ? 1 : u_buf < v ? -1 : 0;
    __inline static SIGN_T Compare(__UNIT_TYPE* u_buf, __UNIT_TYPE u_buf_count, __UNIT_TYPE v_hi, __UNIT_TYPE v_lo)
    {
#ifdef _DEBUG
        if (u_buf_count > 0 && u_buf[u_buf_count - 1] == 0)
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic.h;Compare;1");
#endif
        if (v_hi == 0)
            return (Compare(u_buf, u_buf_count, v_lo));
        else if (u_buf_count < 2)
            return (SIGN_NEGATIVE);
        else if (u_buf_count == 2)
        {
            SIGN_T c = __CompareWord(u_buf[1], v_hi);
            if (c == 0)
                return (__CompareWord(u_buf[0], v_lo));
            else
                return (c);
        }
        else
            return (SIGN_POSITIVE);
    }

    // returns u_buf > v_buf ? 1 : u_buf < v_buf ? -1 : 0;
    __inline static SIGN_T Compare(__UNIT_TYPE* u_buf, __UNIT_TYPE u_buf_count, __UNIT_TYPE* v_buf, __UNIT_TYPE v_buf_count)
    {
#ifdef _DEBUG
        if (u_buf_count > 0 && u_buf[u_buf_count - 1] == 0)
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic.h;Compare;1");
        if (v_buf_count > 0 && v_buf[v_buf_count - 1] == 0)
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic.h;Compare;2");
#endif
        if (u_buf_count == v_buf_count)
        {
            __UNIT_TYPE* u_ptr = &u_buf[u_buf_count];
            __UNIT_TYPE* v_ptr = &v_buf[v_buf_count];
            __UNIT_TYPE count = u_buf_count;
            while (count > 0)
            {
                --u_ptr;
                --v_ptr;
                --count;
                SIGN_T c = __CompareWord(*u_ptr, *v_ptr);
                if (c != 0)
                    return (c);
            }
            return (SIGN_ZERO);
        }
        else if (u_buf_count > v_buf_count)
            return (SIGN_POSITIVE);
        else
            return (SIGN_NEGATIVE);
    }

    __inline static void __BitwiseAnd(__UNIT_TYPE* u, __UNIT_TYPE*v, __UNIT_TYPE*w, __UNIT_TYPE w_count)
    {
        __UNIT_TYPE count = w_count >> 5;
        while (count != 0)
        {
            w[0] = u[0] & v[0];
            w[1] = u[1] & v[1];
            w[2] = u[2] & v[2];
            w[3] = u[3] & v[3];
            w[4] = u[4] & v[4];
            w[5] = u[5] & v[5];
            w[6] = u[6] & v[6];
            w[7] = u[7] & v[7];
            w[8] = u[8] & v[8];
            w[9] = u[9] & v[9];
            w[10] = u[10] & v[10];
            w[11] = u[11] & v[11];
            w[12] = u[12] & v[12];
            w[13] = u[13] & v[13];
            w[14] = u[14] & v[14];
            w[15] = u[15] & v[15];
            w[16] = u[16] & v[16];
            w[17] = u[17] & v[17];
            w[18] = u[18] & v[18];
            w[19] = u[19] & v[19];
            w[20] = u[20] & v[20];
            w[21] = u[21] & v[21];
            w[22] = u[22] & v[22];
            w[23] = u[23] & v[23];
            w[24] = u[24] & v[24];
            w[25] = u[25] & v[25];
            w[26] = u[26] & v[26];
            w[27] = u[27] & v[27];
            w[28] = u[28] & v[28];
            w[29] = u[29] & v[29];
            w[30] = u[30] & v[30];
            w[31] = u[31] & v[31];
            u += 32;
            v += 32;
            w += 32;
            --count;
        }

        if (w_count & 0x10)
        {
            w[0] = u[0] & v[0];
            w[1] = u[1] & v[1];
            w[2] = u[2] & v[2];
            w[3] = u[3] & v[3];
            w[4] = u[4] & v[4];
            w[5] = u[5] & v[5];
            w[6] = u[6] & v[6];
            w[7] = u[7] & v[7];
            w[8] = u[8] & v[8];
            w[9] = u[9] & v[9];
            w[10] = u[10] & v[10];
            w[11] = u[11] & v[11];
            w[12] = u[12] & v[12];
            w[13] = u[13] & v[13];
            w[14] = u[14] & v[14];
            w[15] = u[15] & v[15];
            u += 16;
            v += 16;
            w += 16;
        }

        if (w_count & 0x8)
        {
            w[0] = u[0] & v[0];
            w[1] = u[1] & v[1];
            w[2] = u[2] & v[2];
            w[3] = u[3] & v[3];
            w[4] = u[4] & v[4];
            w[5] = u[5] & v[5];
            w[6] = u[6] & v[6];
            w[7] = u[7] & v[7];
            u += 8;
            v += 8;
            w += 8;
        }

        if (w_count & 0x4)
        {
            w[0] = u[0] & v[0];
            w[1] = u[1] & v[1];
            w[2] = u[2] & v[2];
            w[3] = u[3] & v[3];
            u += 4;
            v += 4;
            w += 4;
        }

        if (w_count & 0x2)
        {
            w[0] = u[0] & v[0];
            w[1] = u[1] & v[1];
            u += 2;
            v += 2;
            w += 2;
        }

        if (w_count & 0x1)
        {
            w[0] = u[0] & v[0];
            u += 1;
            v += 1;
            w += 1;
        }
    }

    // w = u_buf & v;
    __inline static void BitwiseAnd(__UNIT_TYPE* u_buf, __UNIT_TYPE u_buf_count, __UNIT_TYPE v, __UNIT_TYPE& w)
    {
#ifdef _DEBUG
        if (u_buf_count > 0 && u_buf[u_buf_count - 1] == 0)
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic.h;BitwiseAnd;1");
#endif
        if (u_buf_count == 0)
            w = 0;
        else
            w = u_buf[0] & v;
    }

    // w = u_buf & v;
    __inline static void BitwiseAnd(__UNIT_TYPE* u_buf, __UNIT_TYPE u_buf_count, __UNIT_TYPE v_hi, __UNIT_TYPE v_lo, __UNIT_TYPE& w_hi, __UNIT_TYPE& w_lo)
    {
#ifdef _DEBUG
        if (u_buf_count > 0 && u_buf[u_buf_count - 1] == 0)
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic.h;BitwiseAnd;1");
#endif
        if (u_buf_count == 0)
        {
            w_lo = 0;
            w_hi = 0;
        }
        else if (u_buf_count == 1)
        {
            w_lo = u_buf[0] & v_lo;
            w_hi = 0;
        }
        else
        {
            w_lo = u_buf[0] & v_lo;
            w_hi = u_buf[1] & v_hi;
        }
    }

    // w_buf = u_buf & v_buf;
    __inline static void BitwiseAnd(__UNIT_TYPE* u_buf, __UNIT_TYPE u_buf_count, __UNIT_TYPE* v_buf, __UNIT_TYPE v_buf_count, __UNIT_TYPE* w_buf, __UNIT_TYPE w_buf_count)
    {
#ifdef _DEBUG
        if (u_buf_count > 0 && u_buf[u_buf_count - 1] == 0)
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic.h;BitwiseAnd;1");
        if (v_buf_count > 0 && v_buf[v_buf_count - 1] == 0)
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic.h;BitwiseAnd;2");
#endif
        if (u_buf_count >= v_buf_count)
        {
            if (v_buf_count == 0)
                _ZERO_MEMORY_UNIT(w_buf, w_buf_count);
            else
            {
                __BitwiseAnd(u_buf, v_buf, w_buf, v_buf_count);
                _ZERO_MEMORY_UNIT(w_buf + v_buf_count, w_buf_count - v_buf_count);
            }
        }
        else
        {
            if (u_buf_count == 0)
                _ZERO_MEMORY_UNIT(w_buf, w_buf_count);
            else
            {
                __BitwiseAnd(v_buf, u_buf, w_buf, u_buf_count);
                _ZERO_MEMORY_UNIT(w_buf + u_buf_count, w_buf_count - u_buf_count);
            }
        }
    }

    // OR 演算の実装。u_buf_countは 0 であってはならない。v_count は 0 であってはならない。u_buf_count >= v_buf_count でなければならない。
    __inline static void __BitwiseOr(__UNIT_TYPE* u_buf, __UNIT_TYPE u_buf_count, __UNIT_TYPE* v_buf, __UNIT_TYPE v_buf_count, __UNIT_TYPE* w_buf, __UNIT_TYPE w_buf_count)
    {
        __UNIT_TYPE* u = u_buf;
        __UNIT_TYPE* v = v_buf;
        __UNIT_TYPE* w = w_buf;
        __UNIT_TYPE or_count = v_buf_count;

        __UNIT_TYPE count = or_count >> 5;
        while (count > 0)
        {
            w[0] = u[0] | v[0];
            w[1] = u[1] | v[1];
            w[2] = u[2] | v[2];
            w[3] = u[3] | v[3];
            w[4] = u[4] | v[4];
            w[5] = u[5] | v[5];
            w[6] = u[6] | v[6];
            w[7] = u[7] | v[7];
            w[8] = u[8] | v[8];
            w[9] = u[9] | v[9];
            w[10] = u[10] | v[10];
            w[11] = u[11] | v[11];
            w[12] = u[12] | v[12];
            w[13] = u[13] | v[13];
            w[14] = u[14] | v[14];
            w[15] = u[15] | v[15];
            w[16] = u[16] | v[16];
            w[17] = u[17] | v[17];
            w[18] = u[18] | v[18];
            w[19] = u[19] | v[19];
            w[20] = u[20] | v[20];
            w[21] = u[21] | v[21];
            w[22] = u[22] | v[22];
            w[23] = u[23] | v[23];
            w[24] = u[24] | v[24];
            w[25] = u[25] | v[25];
            w[26] = u[26] | v[26];
            w[27] = u[27] | v[27];
            w[28] = u[28] | v[28];
            w[29] = u[29] | v[29];
            w[30] = u[30] | v[30];
            w[31] = u[31] | v[31];
            u += 32;
            v += 32;
            w += 32;
            --count;
        }

        if (or_count & 0x10)
        {
            w[0] = u[0] | v[0];
            w[1] = u[1] | v[1];
            w[2] = u[2] | v[2];
            w[3] = u[3] | v[3];
            w[4] = u[4] | v[4];
            w[5] = u[5] | v[5];
            w[6] = u[6] | v[6];
            w[7] = u[7] | v[7];
            w[8] = u[8] | v[8];
            w[9] = u[9] | v[9];
            w[10] = u[10] | v[10];
            w[11] = u[11] | v[11];
            w[12] = u[12] | v[12];
            w[13] = u[13] | v[13];
            w[14] = u[14] | v[14];
            w[15] = u[15] | v[15];
            u += 16;
            v += 16;
            w += 16;
        }

        if (or_count & 0x8)
        {
            w[0] = u[0] | v[0];
            w[1] = u[1] | v[1];
            w[2] = u[2] | v[2];
            w[3] = u[3] | v[3];
            w[4] = u[4] | v[4];
            w[5] = u[5] | v[5];
            w[6] = u[6] | v[6];
            w[7] = u[7] | v[7];
            u += 8;
            v += 8;
            w += 8;
        }

        if (or_count & 0x4)
        {
            w[0] = u[0] | v[0];
            w[1] = u[1] | v[1];
            w[2] = u[2] | v[2];
            w[3] = u[3] | v[3];
            u += 4;
            v += 4;
            w += 4;
        }

        if (or_count & 0x2)
        {
            w[0] = u[0] | v[0];
            w[1] = u[1] | v[1];
            u += 2;
            v += 2;
            w += 2;
        }

        if (or_count & 0x1)
        {
            w[0] = u[0] | v[0];
            u += 1;
            v += 1;
            w += 1;
        }

        _COPY_MEMORY_UNIT(w_buf + or_count, u_buf + or_count, u_buf_count - or_count);
        _ZERO_MEMORY_UNIT(w_buf + u_buf_count, w_buf_count - u_buf_count);
    }

    // w_buf = u_buf | v;
    __inline static void BitwiseOr(__UNIT_TYPE* u_buf, __UNIT_TYPE u_buf_count, __UNIT_TYPE v, __UNIT_TYPE* w_buf, __UNIT_TYPE w_buf_count)
    {
#ifdef _DEBUG
        if (u_buf_count > 0 && u_buf[u_buf_count - 1] == 0)
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic.h;BitwiseOr;1");
#endif
        if (v == 0)
        {
            _COPY_MEMORY_UNIT(w_buf, u_buf, u_buf_count);
            _ZERO_MEMORY_UNIT(w_buf + u_buf_count, w_buf_count - u_buf_count);
        }
        else if (u_buf_count == 0)
        {
            w_buf[0] = v;
            _ZERO_MEMORY_UNIT(w_buf + 1, w_buf_count - 1);
        }
        else
        {
            w_buf[0] = u_buf[0] | v;
            _COPY_MEMORY_UNIT(w_buf + 1, u_buf + 1, u_buf_count - 1);
            _ZERO_MEMORY_UNIT(w_buf + u_buf_count, w_buf_count - u_buf_count);
        }
    }

    // w_buf = u_buf | v;
    __inline static void BitwiseOr(__UNIT_TYPE* u_buf, __UNIT_TYPE u_buf_count, __UNIT_TYPE v_hi, __UNIT_TYPE v_lo, __UNIT_TYPE* w_buf, __UNIT_TYPE w_buf_count)
    {
#ifdef _DEBUG
        if (u_buf_count > 0 && u_buf[u_buf_count - 1] == 0)
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic.h;BitwiseOr;1");
#endif
        if (v_hi == 0)
            BitwiseOr(u_buf, u_buf_count, v_lo, w_buf, w_buf_count);
        else if (u_buf_count == 0)
        {
            w_buf[0] = v_lo;
            w_buf[1] = v_hi;
            _ZERO_MEMORY_UNIT(w_buf + 2, w_buf_count - 2);
        }
        else if (u_buf_count == 1)
        {
            w_buf[0] = u_buf[0] | v_lo;
            w_buf[1] = v_hi;
            _ZERO_MEMORY_UNIT(w_buf + 2, w_buf_count - 2);
        }
        else
        {
            w_buf[0] = u_buf[0] | v_lo;
            w_buf[1] = u_buf[1] | v_hi;
            _COPY_MEMORY_UNIT(w_buf + 2, u_buf + 2, u_buf_count - 2);
            _ZERO_MEMORY_UNIT(w_buf + u_buf_count, w_buf_count - u_buf_count);
        }
    }

    // w_buf = u_buf | v_buf;
    __inline static void BitwiseOr(__UNIT_TYPE* u_buf, __UNIT_TYPE u_buf_count, __UNIT_TYPE* v_buf, __UNIT_TYPE v_buf_count, __UNIT_TYPE* w_buf, __UNIT_TYPE w_buf_count)
    {
#ifdef _DEBUG
        if (u_buf_count > 0 && u_buf[u_buf_count - 1] == 0)
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic.h;BitwiseOr;1");
        if (v_buf_count > 0 && v_buf[v_buf_count - 1] == 0)
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic.h;BitwiseOr;2");
#endif
        if (u_buf_count >= v_buf_count)
        {
            if (v_buf_count == 0)
            {
                _COPY_MEMORY_UNIT(w_buf, u_buf, u_buf_count);
                _ZERO_MEMORY_UNIT(w_buf + u_buf_count, w_buf_count - u_buf_count);
            }
            else
                __BitwiseOr(u_buf, u_buf_count, v_buf, v_buf_count, w_buf, w_buf_count);
        }
        else
        {
            if (u_buf_count == 0)
            {
                _COPY_MEMORY_UNIT(w_buf, v_buf, v_buf_count);
                _ZERO_MEMORY_UNIT(w_buf + v_buf_count, w_buf_count - v_buf_count);
            }
            else
                __BitwiseOr(v_buf, v_buf_count, u_buf, u_buf_count, w_buf, w_buf_count);
        }
    }

    // XOR 演算の実装。u_buf_count は 0 であってはならない。v_buf_count は 0 であってはならない。u_buf_count >= v_buf_count でなければならない。
    __inline static void __ExclusiveOr(__UNIT_TYPE* u_buf, __UNIT_TYPE u_buf_count, __UNIT_TYPE* v_buf, __UNIT_TYPE v_buf_count, __UNIT_TYPE* w_buf, __UNIT_TYPE w_buf_count)
    {
        __UNIT_TYPE* u = u_buf;
        __UNIT_TYPE u_count = u_buf_count;
        __UNIT_TYPE* v = v_buf;
        __UNIT_TYPE v_count = v_buf_count;
        __UNIT_TYPE* w = w_buf;
        __UNIT_TYPE w_count = w_buf_count;
        __UNIT_TYPE or_count = v_count;
        __UNIT_TYPE cp_count = u_count - v_count;

        __UNIT_TYPE count = or_count >> 5;
        while (count > 0)
        {
            w[0] = u[0] ^ v[0];
            w[1] = u[1] ^ v[1];
            w[2] = u[2] ^ v[2];
            w[3] = u[3] ^ v[3];
            w[4] = u[4] ^ v[4];
            w[5] = u[5] ^ v[5];
            w[6] = u[6] ^ v[6];
            w[7] = u[7] ^ v[7];
            w[8] = u[8] ^ v[8];
            w[9] = u[9] ^ v[9];
            w[10] = u[10] ^ v[10];
            w[11] = u[11] ^ v[11];
            w[12] = u[12] ^ v[12];
            w[13] = u[13] ^ v[13];
            w[14] = u[14] ^ v[14];
            w[15] = u[15] ^ v[15];
            w[16] = u[16] ^ v[16];
            w[17] = u[17] ^ v[17];
            w[18] = u[18] ^ v[18];
            w[19] = u[19] ^ v[19];
            w[20] = u[20] ^ v[20];
            w[21] = u[21] ^ v[21];
            w[22] = u[22] ^ v[22];
            w[23] = u[23] ^ v[23];
            w[24] = u[24] ^ v[24];
            w[25] = u[25] ^ v[25];
            w[26] = u[26] ^ v[26];
            w[27] = u[27] ^ v[27];
            w[28] = u[28] ^ v[28];
            w[29] = u[29] ^ v[29];
            w[30] = u[30] ^ v[30];
            w[31] = u[31] ^ v[31];
            u += 32;
            v += 32;
            w += 32;
            --count;
        }

        if (or_count & 0x10)
        {
            w[0] = u[0] ^ v[0];
            w[1] = u[1] ^ v[1];
            w[2] = u[2] ^ v[2];
            w[3] = u[3] ^ v[3];
            w[4] = u[4] ^ v[4];
            w[5] = u[5] ^ v[5];
            w[6] = u[6] ^ v[6];
            w[7] = u[7] ^ v[7];
            w[8] = u[8] ^ v[8];
            w[9] = u[9] ^ v[9];
            w[10] = u[10] ^ v[10];
            w[11] = u[11] ^ v[11];
            w[12] = u[12] ^ v[12];
            w[13] = u[13] ^ v[13];
            w[14] = u[14] ^ v[14];
            w[15] = u[15] ^ v[15];
            u += 16;
            v += 16;
            w += 16;
        }

        if (or_count & 0x8)
        {
            w[0] = u[0] ^ v[0];
            w[1] = u[1] ^ v[1];
            w[2] = u[2] ^ v[2];
            w[3] = u[3] ^ v[3];
            w[4] = u[4] ^ v[4];
            w[5] = u[5] ^ v[5];
            w[6] = u[6] ^ v[6];
            w[7] = u[7] ^ v[7];
            u += 8;
            v += 8;
            w += 8;
        }

        if (or_count & 0x4)
        {
            w[0] = u[0] ^ v[0];
            w[1] = u[1] ^ v[1];
            w[2] = u[2] ^ v[2];
            w[3] = u[3] ^ v[3];
            u += 4;
            v += 4;
            w += 4;
        }

        if (or_count & 0x2)
        {
            w[0] = u[0] ^ v[0];
            w[1] = u[1] ^ v[1];
            u += 2;
            v += 2;
            w += 2;
        }

        if (or_count & 0x1)
        {
            w[0] = u[0] ^ v[0];
            u += 1;
            v += 1;
            w += 1;
        }

        _COPY_MEMORY_UNIT(w_buf + or_count, u_buf + or_count, u_buf_count - or_count);
        _ZERO_MEMORY_UNIT(w_buf + u_buf_count, w_buf_count - u_buf_count);
    }

    // w_buf = u_buf ^ v;
    __inline static void ExclusiveOr(__UNIT_TYPE* u_buf, __UNIT_TYPE u_buf_count, __UNIT_TYPE v, __UNIT_TYPE* w_buf, __UNIT_TYPE w_buf_count)
    {
#ifdef _DEBUG
        if (u_buf_count > 0 && u_buf[u_buf_count - 1] == 0)
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic.h;ExclusiveOr;1");
#endif
        if (v == 0)
        {
            _COPY_MEMORY_UNIT(w_buf, u_buf, u_buf_count);
            _ZERO_MEMORY_UNIT(w_buf + u_buf_count, w_buf_count - u_buf_count);
        }
        else if (u_buf_count == 0)
        {
            w_buf[0] = v;
            _ZERO_MEMORY_UNIT(w_buf + 1, w_buf_count - 1);
        }
        else
        {
            w_buf[0] = u_buf[0] ^ v;
            _COPY_MEMORY_UNIT(w_buf + 1, u_buf + 1, u_buf_count - 1);
            _ZERO_MEMORY_UNIT(w_buf + u_buf_count, w_buf_count - u_buf_count);
        }
    }

    // w_buf = u_buf ^ v;
    __inline static void ExclusiveOr(__UNIT_TYPE* u_buf, __UNIT_TYPE u_buf_count, __UNIT_TYPE v_hi, __UNIT_TYPE v_lo, __UNIT_TYPE* w_buf, __UNIT_TYPE w_buf_count)
    {
#ifdef _DEBUG
        if (u_buf_count > 0 && u_buf[u_buf_count - 1] == 0)
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic.h;ExclusiveOr;1");
#endif
        if (v_hi == 0)
            ExclusiveOr(u_buf, u_buf_count, v_lo, w_buf, w_buf_count);
        else if (u_buf_count == 0)
        {
            w_buf[0] = v_lo;
            w_buf[1] = v_hi;
            _ZERO_MEMORY_UNIT(w_buf + 2, w_buf_count - 2);
        }
        else if (u_buf_count == 1)
        {
            w_buf[0] = u_buf[0] ^ v_lo;
            w_buf[1] = v_hi;
            _ZERO_MEMORY_UNIT(w_buf + 2, w_buf_count - 2);
        }
        else
        {
            w_buf[0] = u_buf[0] ^ v_lo;
            w_buf[1] = u_buf[1] ^ v_hi;
            _COPY_MEMORY_UNIT(w_buf + 2, u_buf + 2, u_buf_count - 2);
            _ZERO_MEMORY_UNIT(w_buf + u_buf_count, w_buf_count - u_buf_count);
        }
    }

    // w_buf = u_buf ^ v_buf;
    __inline static void ExclusiveOr(__UNIT_TYPE* u_buf, __UNIT_TYPE u_buf_count, __UNIT_TYPE* v_buf, __UNIT_TYPE v_buf_count, __UNIT_TYPE* w_buf, __UNIT_TYPE w_buf_count)
    {
#ifdef _DEBUG
        if (u_buf_count > 0 && u_buf[u_buf_count - 1] == 0)
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic.h;ExclusiveOr;1");
        if (v_buf_count > 0 && v_buf[v_buf_count - 1] == 0)
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic.h;ExclusiveOr;2");
#endif
        if (u_buf_count >= v_buf_count)
        {
            if (v_buf_count == 0)
            {
                _COPY_MEMORY_UNIT(w_buf, u_buf, u_buf_count);
                _ZERO_MEMORY_UNIT(w_buf + u_buf_count, w_buf_count - u_buf_count);
            }
            else
                __ExclusiveOr(u_buf, u_buf_count, v_buf, v_buf_count, w_buf, w_buf_count);
        }
        else
        {
            if (u_buf_count == 0)
            {
                _COPY_MEMORY_UNIT(w_buf, v_buf, v_buf_count);
                _ZERO_MEMORY_UNIT(w_buf + v_buf_count, w_buf_count - v_buf_count);
            }
            else
                __ExclusiveOr(v_buf, v_buf_count, u_buf, u_buf_count, w_buf, w_buf_count);
        }
    }

    __inline static void __OneCompliment_And_BitwiseAnd(__UNIT_TYPE* u_buf, __UNIT_TYPE u_buf_count, __UNIT_TYPE* v_buf, __UNIT_TYPE v_buf_count, __UNIT_TYPE* w_buf, __UNIT_TYPE w_buf_count)
    {
#ifdef _DEBUG
        if (u_buf_count > 0 && u_buf[u_buf_count - 1] == 0)
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic.h;__OneCompliment_And_BitwiseAnd;1");
        if (v_buf_count > 0 && v_buf[v_buf_count - 1] == 0)
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic.h;__OneCompliment_And_BitwiseAnd;2");
        if (u_buf_count > v_buf_count)
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic.h;__OneCompliment_And_BitwiseAnd;3");
        if (w_buf_count < v_buf_count)
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic.h;__OneCompliment_And_BitwiseAnd;4");
        if (v_buf_count < 1)
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic.h;__OneCompliment_And_BitwiseAnd;5");
#endif
        const __UNIT_TYPE* u_ptr = u_buf;
        const __UNIT_TYPE* v_ptr = v_buf;
        __UNIT_TYPE* w_ptr = w_buf;

        __UNIT_TYPE count = u_buf_count >> 5;
        while (count > 0)
        {
            w_ptr[0] = ~u_ptr[0] & v_ptr[0];
            w_ptr[1] = ~u_ptr[1] & v_ptr[1];
            w_ptr[2] = ~u_ptr[2] & v_ptr[2];
            w_ptr[3] = ~u_ptr[3] & v_ptr[3];
            w_ptr[4] = ~u_ptr[4] & v_ptr[4];
            w_ptr[5] = ~u_ptr[5] & v_ptr[5];
            w_ptr[6] = ~u_ptr[6] & v_ptr[6];
            w_ptr[7] = ~u_ptr[7] & v_ptr[7];
            w_ptr[8] = ~u_ptr[8] & v_ptr[8];
            w_ptr[9] = ~u_ptr[9] & v_ptr[9];
            w_ptr[10] = ~u_ptr[10] & v_ptr[10];
            w_ptr[11] = ~u_ptr[11] & v_ptr[11];
            w_ptr[12] = ~u_ptr[12] & v_ptr[12];
            w_ptr[13] = ~u_ptr[13] & v_ptr[13];
            w_ptr[14] = ~u_ptr[14] & v_ptr[14];
            w_ptr[15] = ~u_ptr[15] & v_ptr[15];
            w_ptr[16] = ~u_ptr[16] & v_ptr[16];
            w_ptr[17] = ~u_ptr[17] & v_ptr[17];
            w_ptr[18] = ~u_ptr[18] & v_ptr[18];
            w_ptr[19] = ~u_ptr[19] & v_ptr[19];
            w_ptr[20] = ~u_ptr[20] & v_ptr[20];
            w_ptr[21] = ~u_ptr[21] & v_ptr[21];
            w_ptr[22] = ~u_ptr[22] & v_ptr[22];
            w_ptr[23] = ~u_ptr[23] & v_ptr[23];
            w_ptr[24] = ~u_ptr[24] & v_ptr[24];
            w_ptr[25] = ~u_ptr[25] & v_ptr[25];
            w_ptr[26] = ~u_ptr[26] & v_ptr[26];
            w_ptr[27] = ~u_ptr[27] & v_ptr[27];
            w_ptr[28] = ~u_ptr[28] & v_ptr[28];
            w_ptr[29] = ~u_ptr[29] & v_ptr[29];
            w_ptr[30] = ~u_ptr[30] & v_ptr[30];
            w_ptr[31] = ~u_ptr[31] & v_ptr[31];
            u_ptr += 32;
            v_ptr += 32;
            w_ptr += 32;
            --count;
        }

        if (u_buf_count & 0x10)
        {
            w_ptr[0] = ~u_ptr[0] & v_ptr[0];
            w_ptr[1] = ~u_ptr[1] & v_ptr[1];
            w_ptr[2] = ~u_ptr[2] & v_ptr[2];
            w_ptr[3] = ~u_ptr[3] & v_ptr[3];
            w_ptr[4] = ~u_ptr[4] & v_ptr[4];
            w_ptr[5] = ~u_ptr[5] & v_ptr[5];
            w_ptr[6] = ~u_ptr[6] & v_ptr[6];
            w_ptr[7] = ~u_ptr[7] & v_ptr[7];
            w_ptr[8] = ~u_ptr[8] & v_ptr[8];
            w_ptr[9] = ~u_ptr[9] & v_ptr[9];
            w_ptr[10] = ~u_ptr[10] & v_ptr[10];
            w_ptr[11] = ~u_ptr[11] & v_ptr[11];
            w_ptr[12] = ~u_ptr[12] & v_ptr[12];
            w_ptr[13] = ~u_ptr[13] & v_ptr[13];
            w_ptr[14] = ~u_ptr[14] & v_ptr[14];
            w_ptr[15] = ~u_ptr[15] & v_ptr[15];
            u_ptr += 16;
            v_ptr += 16;
            w_ptr += 16;
        }

        if (u_buf_count & 0x8)
        {
            w_ptr[0] = ~u_ptr[0] & v_ptr[0];
            w_ptr[1] = ~u_ptr[1] & v_ptr[1];
            w_ptr[2] = ~u_ptr[2] & v_ptr[2];
            w_ptr[3] = ~u_ptr[3] & v_ptr[3];
            w_ptr[4] = ~u_ptr[4] & v_ptr[4];
            w_ptr[5] = ~u_ptr[5] & v_ptr[5];
            w_ptr[6] = ~u_ptr[6] & v_ptr[6];
            w_ptr[7] = ~u_ptr[7] & v_ptr[7];
            u_ptr += 8;
            v_ptr += 8;
            w_ptr += 8;
        }

        if (u_buf_count & 0x4)
        {
            w_ptr[0] = ~u_ptr[0] & v_ptr[0];
            w_ptr[1] = ~u_ptr[1] & v_ptr[1];
            w_ptr[2] = ~u_ptr[2] & v_ptr[2];
            w_ptr[3] = ~u_ptr[3] & v_ptr[3];
            u_ptr += 4;
            v_ptr += 4;
            w_ptr += 4;
        }

        if (u_buf_count & 0x2)
        {
            w_ptr[0] = ~u_ptr[0] & v_ptr[0];
            w_ptr[1] = ~u_ptr[1] & v_ptr[1];
            u_ptr += 2;
            v_ptr += 2;
            w_ptr += 2;
        }

        if (u_buf_count & 0x1)
        {
            w_ptr[0] = ~u_ptr[0] & v_ptr[0];
            u_ptr += 1;
            v_ptr += 1;
            w_ptr += 1;
        }

        _COPY_MEMORY_UNIT(w_buf + u_buf_count, v_buf + u_buf_count, v_buf_count - u_buf_count);
        _ZERO_MEMORY_UNIT(w_buf + v_buf_count, w_buf_count - v_buf_count);
    }

    // w_buf = ~u & v_buf;
    __inline static void OneCompliment_And_BitwiseAnd(__UNIT_TYPE u, __UNIT_TYPE* v_buf, __UNIT_TYPE v_buf_count, __UNIT_TYPE* w_buf, __UNIT_TYPE w_buf_count)
    {
#ifdef _DEBUG
        if (v_buf_count > 0 && v_buf[v_buf_count - 1] == 0)
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic.h;OneCompliment_And_BitwiseAnd;1");
        if (v_buf_count < 1)
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic.h;OneCompliment_And_BitwiseAnd;2");
#endif
        if (u == 0)
        {
            _COPY_MEMORY_UNIT(w_buf, v_buf, v_buf_count);
            _ZERO_MEMORY_UNIT(w_buf + v_buf_count, w_buf_count - v_buf_count);
        }
        else if (v_buf_count == 0)
            _ZERO_MEMORY_UNIT(w_buf, w_buf_count);
        else
        {
            w_buf[0] = ~u & v_buf[0];
            _COPY_MEMORY_UNIT(w_buf + 1, v_buf + 1, v_buf_count - 1);
            _ZERO_MEMORY_UNIT(w_buf + v_buf_count, w_buf_count - v_buf_count);
        }
    }

    // w_buf = ~u & v_buf;
    __inline static void OneCompliment_And_BitwiseAnd(__UNIT_TYPE u_hi, __UNIT_TYPE u_lo, __UNIT_TYPE* v_buf, __UNIT_TYPE v_buf_count, __UNIT_TYPE* w_buf, __UNIT_TYPE w_buf_count)
    {
#ifdef _DEBUG
        if (v_buf_count > 0 && v_buf[v_buf_count - 1] == 0)
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic.h;OneCompliment_And_BitwiseAnd;1");
        if (v_buf_count < 1)
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic.h;OneCompliment_And_BitwiseAnd;2");
#endif
        if (u_hi == 0)
            OneCompliment_And_BitwiseAnd(u_lo, v_buf, v_buf_count, w_buf, w_buf_count);
        else if (v_buf_count == 0)
            _ZERO_MEMORY_UNIT(w_buf, w_buf_count);
        else if (v_buf_count == 1)
        {
            w_buf[0] = ~u_lo & v_buf[0];
            _ZERO_MEMORY_UNIT(w_buf + 1, w_buf_count - 1);
        }
        else
        {
            w_buf[0] = ~u_lo & v_buf[0];
            w_buf[1] = ~u_hi & v_buf[1];
            _COPY_MEMORY_UNIT(w_buf + 2, v_buf + 2, v_buf_count - 2);
            _ZERO_MEMORY_UNIT(w_buf + v_buf_count, w_buf_count - v_buf_count);
        }
    }

    // w = ~u_buf & v;
    __inline static void OneCompliment_And_BitwiseAnd(__UNIT_TYPE* u_buf, __UNIT_TYPE u_buf_count, __UNIT_TYPE v, __UNIT_TYPE& w)
    {
        if (v == 0)
            w = 0;
        else if (u_buf_count == 0)
            w = v;
        else
            w = ~u_buf[0] & v;
    }

    // w = ~u_buf & v;
    __inline static void OneCompliment_And_BitwiseAnd(__UNIT_TYPE* u_buf, __UNIT_TYPE u_buf_count, __UNIT_TYPE v_hi, __UNIT_TYPE v_lo, __UNIT_TYPE& w_hi, __UNIT_TYPE& w_lo)
    {
        if (v_hi == 0)
        {
            OneCompliment_And_BitwiseAnd(u_buf, u_buf_count, v_lo, w_lo);
            w_hi = 0;
        }
        else if (u_buf_count == 0)
        {
            w_lo = v_lo;
            w_hi = v_hi;
        }
        else if (u_buf_count == 1)
        {
            w_lo = ~u_buf[0] & v_lo;
            w_hi = v_hi;
        }
        else
        {
            w_lo = ~u_buf[0] & v_lo;
            w_hi = ~u_buf[1] & v_hi;
        }
    }

    // w_buf = ~u_buf & v_buf;
    __inline static void OneCompliment_And_BitwiseAnd(__UNIT_TYPE* u_buf, __UNIT_TYPE u_buf_count, __UNIT_TYPE* v_buf, __UNIT_TYPE v_buf_count, __UNIT_TYPE* w_buf, __UNIT_TYPE w_buf_count)
    {
        if (u_buf_count > v_buf_count)
            u_buf_count = __Shrink(u_buf, v_buf_count);
        if (u_buf_count == 0)
        {
            _COPY_MEMORY_UNIT(w_buf, v_buf, v_buf_count);
            _ZERO_MEMORY_UNIT(w_buf + v_buf_count, w_buf_count - v_buf_count);
        }
        else if (v_buf_count == 0)
            _ZERO_MEMORY_UNIT(w_buf, w_buf_count);
        else
            __OneCompliment_And_BitwiseAnd(u_buf, u_buf_count, v_buf, v_buf_count, w_buf, w_buf_count);
    }

    __inline static __UNIT_TYPE __RightShift_UNIT(__UNIT_TYPE k, __UNIT_TYPE* in_p, _UINT32_T n_lshift_bit_count, _UINT32_T n_rshift_bit_count, __UNIT_TYPE* out_p)
    {
        __UNIT_TYPE data = in_p[0];
        k |= data << n_lshift_bit_count;
        out_p[0] = k;
        k = data >> n_rshift_bit_count;
        return (k);
    }

    __inline static void __RightShift(__UNIT_TYPE* in_buf, __UNIT_TYPE in_buf_count, __UNIT_TYPE n, __UNIT_TYPE* out_buf, __UNIT_TYPE out_buf_count)
    {
#ifdef _DEBUG
        if (in_buf_count > 0 && in_buf[in_buf_count - 1] == 0)
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic.h;__RightShift;1");
        if (out_buf_count + n / __UNIT_TYPE_BIT_COUNT < in_buf_count)
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic.h;__RightShift;2");
#endif
        // n_word_count ワード右に移動し、更に n_bit_count ビット右に移動する。
        __UNIT_TYPE n_word_count = n / __UNIT_TYPE_BIT_COUNT;
        _UINT32_T n_rshift_bit_count = n % __UNIT_TYPE_BIT_COUNT;
        if (n_rshift_bit_count == 0)
        {
            // シフト数がちょうどワード境界分であれば単にワード単位のデータ移動のみ行う。
            _COPY_MEMORY_UNIT(out_buf, in_buf + n_word_count, in_buf_count - n_word_count);
            _ZERO_MEMORY_UNIT(out_buf + (in_buf_count - n_word_count), out_buf_count - (in_buf_count - n_word_count));
        }
        else
        {
            __UNIT_TYPE* in_ptr = in_buf + n_word_count;
            __UNIT_TYPE* out_ptr = out_buf;
            _UINT32_T n_lshift_bit_count = __UNIT_TYPE_BIT_COUNT - n_rshift_bit_count;
            __UNIT_TYPE k = *in_ptr >> n_rshift_bit_count;
            __UNIT_TYPE t_count = in_buf_count - n_word_count - 1;
            __UNIT_TYPE count = t_count >> 5;
            while (count > 0)
            {
                k = __RightShift_UNIT(k, in_ptr + 1, n_lshift_bit_count, n_rshift_bit_count, out_ptr + 0);
                k = __RightShift_UNIT(k, in_ptr + 2, n_lshift_bit_count, n_rshift_bit_count, out_ptr + 1);
                k = __RightShift_UNIT(k, in_ptr + 3, n_lshift_bit_count, n_rshift_bit_count, out_ptr + 2);
                k = __RightShift_UNIT(k, in_ptr + 4, n_lshift_bit_count, n_rshift_bit_count, out_ptr + 3);
                k = __RightShift_UNIT(k, in_ptr + 5, n_lshift_bit_count, n_rshift_bit_count, out_ptr + 4);
                k = __RightShift_UNIT(k, in_ptr + 6, n_lshift_bit_count, n_rshift_bit_count, out_ptr + 5);
                k = __RightShift_UNIT(k, in_ptr + 7, n_lshift_bit_count, n_rshift_bit_count, out_ptr + 6);
                k = __RightShift_UNIT(k, in_ptr + 8, n_lshift_bit_count, n_rshift_bit_count, out_ptr + 7);
                k = __RightShift_UNIT(k, in_ptr + 9, n_lshift_bit_count, n_rshift_bit_count, out_ptr + 8);
                k = __RightShift_UNIT(k, in_ptr + 10, n_lshift_bit_count, n_rshift_bit_count, out_ptr + 9);
                k = __RightShift_UNIT(k, in_ptr + 11, n_lshift_bit_count, n_rshift_bit_count, out_ptr + 10);
                k = __RightShift_UNIT(k, in_ptr + 12, n_lshift_bit_count, n_rshift_bit_count, out_ptr + 11);
                k = __RightShift_UNIT(k, in_ptr + 13, n_lshift_bit_count, n_rshift_bit_count, out_ptr + 12);
                k = __RightShift_UNIT(k, in_ptr + 14, n_lshift_bit_count, n_rshift_bit_count, out_ptr + 13);
                k = __RightShift_UNIT(k, in_ptr + 15, n_lshift_bit_count, n_rshift_bit_count, out_ptr + 14);
                k = __RightShift_UNIT(k, in_ptr + 16, n_lshift_bit_count, n_rshift_bit_count, out_ptr + 15);
                k = __RightShift_UNIT(k, in_ptr + 17, n_lshift_bit_count, n_rshift_bit_count, out_ptr + 16);
                k = __RightShift_UNIT(k, in_ptr + 18, n_lshift_bit_count, n_rshift_bit_count, out_ptr + 17);
                k = __RightShift_UNIT(k, in_ptr + 19, n_lshift_bit_count, n_rshift_bit_count, out_ptr + 18);
                k = __RightShift_UNIT(k, in_ptr + 20, n_lshift_bit_count, n_rshift_bit_count, out_ptr + 19);
                k = __RightShift_UNIT(k, in_ptr + 21, n_lshift_bit_count, n_rshift_bit_count, out_ptr + 20);
                k = __RightShift_UNIT(k, in_ptr + 22, n_lshift_bit_count, n_rshift_bit_count, out_ptr + 21);
                k = __RightShift_UNIT(k, in_ptr + 23, n_lshift_bit_count, n_rshift_bit_count, out_ptr + 22);
                k = __RightShift_UNIT(k, in_ptr + 24, n_lshift_bit_count, n_rshift_bit_count, out_ptr + 23);
                k = __RightShift_UNIT(k, in_ptr + 25, n_lshift_bit_count, n_rshift_bit_count, out_ptr + 24);
                k = __RightShift_UNIT(k, in_ptr + 26, n_lshift_bit_count, n_rshift_bit_count, out_ptr + 25);
                k = __RightShift_UNIT(k, in_ptr + 27, n_lshift_bit_count, n_rshift_bit_count, out_ptr + 26);
                k = __RightShift_UNIT(k, in_ptr + 28, n_lshift_bit_count, n_rshift_bit_count, out_ptr + 27);
                k = __RightShift_UNIT(k, in_ptr + 29, n_lshift_bit_count, n_rshift_bit_count, out_ptr + 28);
                k = __RightShift_UNIT(k, in_ptr + 30, n_lshift_bit_count, n_rshift_bit_count, out_ptr + 29);
                k = __RightShift_UNIT(k, in_ptr + 31, n_lshift_bit_count, n_rshift_bit_count, out_ptr + 30);
                k = __RightShift_UNIT(k, in_ptr + 32, n_lshift_bit_count, n_rshift_bit_count, out_ptr + 31);
                --count;
                in_ptr += 32;
                out_ptr += 32;
            }

            if (t_count & 0x10)
            {
                k = __RightShift_UNIT(k, in_ptr + 1, n_lshift_bit_count, n_rshift_bit_count, out_ptr + 0);
                k = __RightShift_UNIT(k, in_ptr + 2, n_lshift_bit_count, n_rshift_bit_count, out_ptr + 1);
                k = __RightShift_UNIT(k, in_ptr + 3, n_lshift_bit_count, n_rshift_bit_count, out_ptr + 2);
                k = __RightShift_UNIT(k, in_ptr + 4, n_lshift_bit_count, n_rshift_bit_count, out_ptr + 3);
                k = __RightShift_UNIT(k, in_ptr + 5, n_lshift_bit_count, n_rshift_bit_count, out_ptr + 4);
                k = __RightShift_UNIT(k, in_ptr + 6, n_lshift_bit_count, n_rshift_bit_count, out_ptr + 5);
                k = __RightShift_UNIT(k, in_ptr + 7, n_lshift_bit_count, n_rshift_bit_count, out_ptr + 6);
                k = __RightShift_UNIT(k, in_ptr + 8, n_lshift_bit_count, n_rshift_bit_count, out_ptr + 7);
                k = __RightShift_UNIT(k, in_ptr + 9, n_lshift_bit_count, n_rshift_bit_count, out_ptr + 8);
                k = __RightShift_UNIT(k, in_ptr + 10, n_lshift_bit_count, n_rshift_bit_count, out_ptr + 9);
                k = __RightShift_UNIT(k, in_ptr + 11, n_lshift_bit_count, n_rshift_bit_count, out_ptr + 10);
                k = __RightShift_UNIT(k, in_ptr + 12, n_lshift_bit_count, n_rshift_bit_count, out_ptr + 11);
                k = __RightShift_UNIT(k, in_ptr + 13, n_lshift_bit_count, n_rshift_bit_count, out_ptr + 12);
                k = __RightShift_UNIT(k, in_ptr + 14, n_lshift_bit_count, n_rshift_bit_count, out_ptr + 13);
                k = __RightShift_UNIT(k, in_ptr + 15, n_lshift_bit_count, n_rshift_bit_count, out_ptr + 14);
                k = __RightShift_UNIT(k, in_ptr + 16, n_lshift_bit_count, n_rshift_bit_count, out_ptr + 15);
                in_ptr += 16;
                out_ptr += 16;
            }

            if (t_count & 0x8)
            {
                k = __RightShift_UNIT(k, in_ptr + 1, n_lshift_bit_count, n_rshift_bit_count, out_ptr + 0);
                k = __RightShift_UNIT(k, in_ptr + 2, n_lshift_bit_count, n_rshift_bit_count, out_ptr + 1);
                k = __RightShift_UNIT(k, in_ptr + 3, n_lshift_bit_count, n_rshift_bit_count, out_ptr + 2);
                k = __RightShift_UNIT(k, in_ptr + 4, n_lshift_bit_count, n_rshift_bit_count, out_ptr + 3);
                k = __RightShift_UNIT(k, in_ptr + 5, n_lshift_bit_count, n_rshift_bit_count, out_ptr + 4);
                k = __RightShift_UNIT(k, in_ptr + 6, n_lshift_bit_count, n_rshift_bit_count, out_ptr + 5);
                k = __RightShift_UNIT(k, in_ptr + 7, n_lshift_bit_count, n_rshift_bit_count, out_ptr + 6);
                k = __RightShift_UNIT(k, in_ptr + 8, n_lshift_bit_count, n_rshift_bit_count, out_ptr + 7);
                in_ptr += 8;
                out_ptr += 8;
            }

            if (t_count & 0x4)
            {
                k = __RightShift_UNIT(k, in_ptr + 1, n_lshift_bit_count, n_rshift_bit_count, out_ptr + 0);
                k = __RightShift_UNIT(k, in_ptr + 2, n_lshift_bit_count, n_rshift_bit_count, out_ptr + 1);
                k = __RightShift_UNIT(k, in_ptr + 3, n_lshift_bit_count, n_rshift_bit_count, out_ptr + 2);
                k = __RightShift_UNIT(k, in_ptr + 4, n_lshift_bit_count, n_rshift_bit_count, out_ptr + 3);
                in_ptr += 4;
                out_ptr += 4;
            }

            if (t_count & 0x2)
            {
                k = __RightShift_UNIT(k, in_ptr + 1, n_lshift_bit_count, n_rshift_bit_count, out_ptr + 0);
                k = __RightShift_UNIT(k, in_ptr + 2, n_lshift_bit_count, n_rshift_bit_count, out_ptr + 1);
                in_ptr += 2;
                out_ptr += 2;
            }

            if (t_count & 0x1)
            {
                k = __RightShift_UNIT(k, in_ptr + 1, n_lshift_bit_count, n_rshift_bit_count, out_ptr + 0);
                in_ptr += 1;
                out_ptr += 1;
            }

            *out_ptr = k;

            _ZERO_MEMORY_UNIT(out_buf + (in_buf_count - n_word_count), out_buf_count - (in_buf_count - n_word_count));
        }
    }

    // u_buf >>= n;
    __inline static void RightShift(__UNIT_TYPE* inout_buf, __UNIT_TYPE inoput_buf_count, __UNIT_TYPE n)
    {
        if (n == 0)
        {
            // nop
        }
        else
        {
            __UNIT_TYPE in_buf_count = __Shrink(inout_buf, inoput_buf_count);
            if (in_buf_count == 0)
            {
                // nop
            }
            else if (n >= in_buf_count * __UNIT_TYPE_BIT_COUNT)
                _ZERO_MEMORY_UNIT(inout_buf, in_buf_count);
            else
                __RightShift(inout_buf, in_buf_count, n, inout_buf, in_buf_count);
        }
    }

    // r_buf = u_buf >> n;
    __inline static void RightShift(__UNIT_TYPE* in_buf, __UNIT_TYPE in_buf_count, __UNIT_TYPE n, __UNIT_TYPE* out_buf, __UNIT_TYPE out_buf_count)
    {
#ifdef _DEBUG
        if (in_buf_count > 0 && in_buf[in_buf_count - 1] == 0)
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic.h;RightShift;1");
#endif
        if (n == 0)
        {
            _COPY_MEMORY_UNIT(out_buf, in_buf, in_buf_count);
            _ZERO_MEMORY_UNIT(out_buf + in_buf_count, out_buf_count - in_buf_count);
        }
        else if (n >= in_buf_count * __UNIT_TYPE_BIT_COUNT)
            _ZERO_MEMORY_UNIT(out_buf, out_buf_count);
        else if (in_buf_count == 0)
            _ZERO_MEMORY_UNIT(out_buf, out_buf_count);
        else
            __RightShift(in_buf, in_buf_count, n, out_buf, out_buf_count);
    }

    __inline static __UNIT_TYPE __LeftShift_UNIT(__UNIT_TYPE k, __UNIT_TYPE* in_p, _UINT32_T n_lshift_bit_count, _UINT32_T n_rshift_bit_count, __UNIT_TYPE* out_p)
    {
        __UNIT_TYPE data = in_p[0];
        k |= data >> n_rshift_bit_count;
        out_p[0] = k;
        k = data << n_lshift_bit_count;
        return (k);
    }

    __inline static void __LeftShift(__UNIT_TYPE* in_buf, __UNIT_TYPE in_buf_count, __UNIT_TYPE n, __UNIT_TYPE* out_buf, __UNIT_TYPE out_buf_count)
    {
#ifdef _DEBUG
        if (in_buf_count == 0)
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic.h;__LeftShift;1");
        if (in_buf_count > 0 && in_buf[in_buf_count - 1] == 0)
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic.h;__LeftShift;2");
        if (out_buf_count < in_buf_count + n / __UNIT_TYPE_BIT_COUNT)
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic.h;__LeftShift;3");
#endif
        __UNIT_TYPE n_word_count = n / __UNIT_TYPE_BIT_COUNT;
        _UINT32_T n_lshift_bit_count = n % __UNIT_TYPE_BIT_COUNT;
        if (n_lshift_bit_count == 0)
        {
            // シフト数がちょうどワード境界分であれば単にワード単位のデータ移動のみ行う。
            _COPY_MEMORY_REV_UNIT(out_buf + n_word_count, in_buf, in_buf_count);
            _ZERO_MEMORY_UNIT(out_buf + (in_buf_count + n_word_count), out_buf_count - (in_buf_count + n_word_count));
            _ZERO_MEMORY_UNIT(out_buf, n_word_count);
        }
        else
        {
            __UNIT_TYPE* in_ptr = in_buf + in_buf_count - 1;
            __UNIT_TYPE* out_ptr = out_buf + in_buf_count - 1 + n_word_count;
            _UINT32_T n_rshift_bit_count = __UNIT_TYPE_BIT_COUNT - n_lshift_bit_count;
            __UNIT_TYPE k;
            {
                // 最上位 1 ワードのシフト
                // シフト結果の最上位 1 ワードが 0 ならば、その 1 ワードは w_buf に格納しない
                __UNIT_TYPE data = in_ptr[0];
                k = data >> n_rshift_bit_count;
                if (k == 0)
                    _ZERO_MEMORY_UNIT(out_buf + (in_buf_count + n_word_count), out_buf_count - (in_buf_count + n_word_count));
                else
                {
#ifdef _DEBUG
                    if (out_buf_count <= in_buf_count + n_word_count)
                        throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic.h;__LeftShift;4");
#endif
                    out_ptr[1] = k;
                    _ZERO_MEMORY_UNIT(out_buf + (in_buf_count + n_word_count + 1), out_buf_count - (in_buf_count + n_word_count + 1));
                }
                k = data << n_lshift_bit_count;
            }
            __UNIT_TYPE t_count = in_buf_count - 1;
            __UNIT_TYPE count = t_count >> 5;
            while (count > 0)
            {
                k = __LeftShift_UNIT(k, in_ptr - 1, n_lshift_bit_count, n_rshift_bit_count, out_ptr - 0);
                k = __LeftShift_UNIT(k, in_ptr - 2, n_lshift_bit_count, n_rshift_bit_count, out_ptr - 1);
                k = __LeftShift_UNIT(k, in_ptr - 3, n_lshift_bit_count, n_rshift_bit_count, out_ptr - 2);
                k = __LeftShift_UNIT(k, in_ptr - 4, n_lshift_bit_count, n_rshift_bit_count, out_ptr - 3);
                k = __LeftShift_UNIT(k, in_ptr - 5, n_lshift_bit_count, n_rshift_bit_count, out_ptr - 4);
                k = __LeftShift_UNIT(k, in_ptr - 6, n_lshift_bit_count, n_rshift_bit_count, out_ptr - 5);
                k = __LeftShift_UNIT(k, in_ptr - 7, n_lshift_bit_count, n_rshift_bit_count, out_ptr - 6);
                k = __LeftShift_UNIT(k, in_ptr - 8, n_lshift_bit_count, n_rshift_bit_count, out_ptr - 7);
                k = __LeftShift_UNIT(k, in_ptr - 9, n_lshift_bit_count, n_rshift_bit_count, out_ptr - 8);
                k = __LeftShift_UNIT(k, in_ptr - 10, n_lshift_bit_count, n_rshift_bit_count, out_ptr - 9);
                k = __LeftShift_UNIT(k, in_ptr - 11, n_lshift_bit_count, n_rshift_bit_count, out_ptr - 10);
                k = __LeftShift_UNIT(k, in_ptr - 12, n_lshift_bit_count, n_rshift_bit_count, out_ptr - 11);
                k = __LeftShift_UNIT(k, in_ptr - 13, n_lshift_bit_count, n_rshift_bit_count, out_ptr - 12);
                k = __LeftShift_UNIT(k, in_ptr - 14, n_lshift_bit_count, n_rshift_bit_count, out_ptr - 13);
                k = __LeftShift_UNIT(k, in_ptr - 15, n_lshift_bit_count, n_rshift_bit_count, out_ptr - 14);
                k = __LeftShift_UNIT(k, in_ptr - 16, n_lshift_bit_count, n_rshift_bit_count, out_ptr - 15);
                k = __LeftShift_UNIT(k, in_ptr - 17, n_lshift_bit_count, n_rshift_bit_count, out_ptr - 16);
                k = __LeftShift_UNIT(k, in_ptr - 18, n_lshift_bit_count, n_rshift_bit_count, out_ptr - 17);
                k = __LeftShift_UNIT(k, in_ptr - 19, n_lshift_bit_count, n_rshift_bit_count, out_ptr - 18);
                k = __LeftShift_UNIT(k, in_ptr - 20, n_lshift_bit_count, n_rshift_bit_count, out_ptr - 19);
                k = __LeftShift_UNIT(k, in_ptr - 21, n_lshift_bit_count, n_rshift_bit_count, out_ptr - 20);
                k = __LeftShift_UNIT(k, in_ptr - 22, n_lshift_bit_count, n_rshift_bit_count, out_ptr - 21);
                k = __LeftShift_UNIT(k, in_ptr - 23, n_lshift_bit_count, n_rshift_bit_count, out_ptr - 22);
                k = __LeftShift_UNIT(k, in_ptr - 24, n_lshift_bit_count, n_rshift_bit_count, out_ptr - 23);
                k = __LeftShift_UNIT(k, in_ptr - 25, n_lshift_bit_count, n_rshift_bit_count, out_ptr - 24);
                k = __LeftShift_UNIT(k, in_ptr - 26, n_lshift_bit_count, n_rshift_bit_count, out_ptr - 25);
                k = __LeftShift_UNIT(k, in_ptr - 27, n_lshift_bit_count, n_rshift_bit_count, out_ptr - 26);
                k = __LeftShift_UNIT(k, in_ptr - 28, n_lshift_bit_count, n_rshift_bit_count, out_ptr - 27);
                k = __LeftShift_UNIT(k, in_ptr - 29, n_lshift_bit_count, n_rshift_bit_count, out_ptr - 28);
                k = __LeftShift_UNIT(k, in_ptr - 30, n_lshift_bit_count, n_rshift_bit_count, out_ptr - 29);
                k = __LeftShift_UNIT(k, in_ptr - 31, n_lshift_bit_count, n_rshift_bit_count, out_ptr - 30);
                k = __LeftShift_UNIT(k, in_ptr - 32, n_lshift_bit_count, n_rshift_bit_count, out_ptr - 31);
                in_ptr -= 32;
                out_ptr -= 32;
                --count;
            }

            if (t_count & 0x10)
            {
                k = __LeftShift_UNIT(k, in_ptr - 1, n_lshift_bit_count, n_rshift_bit_count, out_ptr - 0);
                k = __LeftShift_UNIT(k, in_ptr - 2, n_lshift_bit_count, n_rshift_bit_count, out_ptr - 1);
                k = __LeftShift_UNIT(k, in_ptr - 3, n_lshift_bit_count, n_rshift_bit_count, out_ptr - 2);
                k = __LeftShift_UNIT(k, in_ptr - 4, n_lshift_bit_count, n_rshift_bit_count, out_ptr - 3);
                k = __LeftShift_UNIT(k, in_ptr - 5, n_lshift_bit_count, n_rshift_bit_count, out_ptr - 4);
                k = __LeftShift_UNIT(k, in_ptr - 6, n_lshift_bit_count, n_rshift_bit_count, out_ptr - 5);
                k = __LeftShift_UNIT(k, in_ptr - 7, n_lshift_bit_count, n_rshift_bit_count, out_ptr - 6);
                k = __LeftShift_UNIT(k, in_ptr - 8, n_lshift_bit_count, n_rshift_bit_count, out_ptr - 7);
                k = __LeftShift_UNIT(k, in_ptr - 9, n_lshift_bit_count, n_rshift_bit_count, out_ptr - 8);
                k = __LeftShift_UNIT(k, in_ptr - 10, n_lshift_bit_count, n_rshift_bit_count, out_ptr - 9);
                k = __LeftShift_UNIT(k, in_ptr - 11, n_lshift_bit_count, n_rshift_bit_count, out_ptr - 10);
                k = __LeftShift_UNIT(k, in_ptr - 12, n_lshift_bit_count, n_rshift_bit_count, out_ptr - 11);
                k = __LeftShift_UNIT(k, in_ptr - 13, n_lshift_bit_count, n_rshift_bit_count, out_ptr - 12);
                k = __LeftShift_UNIT(k, in_ptr - 14, n_lshift_bit_count, n_rshift_bit_count, out_ptr - 13);
                k = __LeftShift_UNIT(k, in_ptr - 15, n_lshift_bit_count, n_rshift_bit_count, out_ptr - 14);
                k = __LeftShift_UNIT(k, in_ptr - 16, n_lshift_bit_count, n_rshift_bit_count, out_ptr - 15);
                in_ptr -= 16;
                out_ptr -= 16;
            }

            if (t_count & 0x8)
            {
                k = __LeftShift_UNIT(k, in_ptr - 1, n_lshift_bit_count, n_rshift_bit_count, out_ptr - 0);
                k = __LeftShift_UNIT(k, in_ptr - 2, n_lshift_bit_count, n_rshift_bit_count, out_ptr - 1);
                k = __LeftShift_UNIT(k, in_ptr - 3, n_lshift_bit_count, n_rshift_bit_count, out_ptr - 2);
                k = __LeftShift_UNIT(k, in_ptr - 4, n_lshift_bit_count, n_rshift_bit_count, out_ptr - 3);
                k = __LeftShift_UNIT(k, in_ptr - 5, n_lshift_bit_count, n_rshift_bit_count, out_ptr - 4);
                k = __LeftShift_UNIT(k, in_ptr - 6, n_lshift_bit_count, n_rshift_bit_count, out_ptr - 5);
                k = __LeftShift_UNIT(k, in_ptr - 7, n_lshift_bit_count, n_rshift_bit_count, out_ptr - 6);
                k = __LeftShift_UNIT(k, in_ptr - 8, n_lshift_bit_count, n_rshift_bit_count, out_ptr - 7);
                in_ptr -= 8;
                out_ptr -= 8;
            }

            if (t_count & 0x4)
            {
                k = __LeftShift_UNIT(k, in_ptr - 1, n_lshift_bit_count, n_rshift_bit_count, out_ptr - 0);
                k = __LeftShift_UNIT(k, in_ptr - 2, n_lshift_bit_count, n_rshift_bit_count, out_ptr - 1);
                k = __LeftShift_UNIT(k, in_ptr - 3, n_lshift_bit_count, n_rshift_bit_count, out_ptr - 2);
                k = __LeftShift_UNIT(k, in_ptr - 4, n_lshift_bit_count, n_rshift_bit_count, out_ptr - 3);
                in_ptr -= 4;
                out_ptr -= 4;
            }

            if (t_count & 0x2)
            {
                k = __LeftShift_UNIT(k, in_ptr - 1, n_lshift_bit_count, n_rshift_bit_count, out_ptr - 0);
                k = __LeftShift_UNIT(k, in_ptr - 2, n_lshift_bit_count, n_rshift_bit_count, out_ptr - 1);
                in_ptr -= 2;
                out_ptr -= 2;
            }

            if (t_count & 0x1)
            {
                k = __LeftShift_UNIT(k, in_ptr - 1, n_lshift_bit_count, n_rshift_bit_count, out_ptr - 0);
                in_ptr -= 1;
                out_ptr -= 1;
            }
            *out_ptr = k;

            _ZERO_MEMORY_UNIT(out_buf, n_word_count);
        }
    }

    // u_buf <<= n;
    __inline static void LeftShift(__UNIT_TYPE* inout_buf, __UNIT_TYPE inoput_buf_count, __UNIT_TYPE n)
    {
        if (n == 0)
        {
            // nop
        }
        else
        {
            __UNIT_TYPE in_buf_count = __Shrink(inout_buf, in_buf_count);
            if (in_buf_count == 0)
            {
                // nop
            }
            else
                __LeftShift(inout_buf, in_buf_count, n, inout_buf, inoput_buf_count);
        }
    }

    // r_buf = u_buf << n;
    __inline static void LeftShift(__UNIT_TYPE* in_buf, __UNIT_TYPE in_buf_count, __UNIT_TYPE n, __UNIT_TYPE* out_buf, __UNIT_TYPE out_buf_count)
    {
#ifdef _DEBUG
        if (in_buf_count > 0 && in_buf[in_buf_count - 1] == 0)
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic.h;LeftShift;1");
#endif
        if (n == 0)
        {
            _COPY_MEMORY_UNIT(out_buf, in_buf, in_buf_count);
            _ZERO_MEMORY_UNIT(out_buf + in_buf_count, out_buf_count - in_buf_count);
        }
        else if (in_buf_count == 0)
            _ZERO_MEMORY_UNIT(out_buf, out_buf_count);
        else
            __LeftShift(in_buf, in_buf_count, n, out_buf, out_buf_count);
    }

    __inline static __UNIT_TYPE __TZCount(__UNIT_TYPE* buf, __UNIT_TYPE count)
    {
        int tz_count = 0;
        while (count > 0)
        {
            if (*buf != 0)
                return (tz_count + _TZCNT_ALT_UNIT(*buf));
            tz_count += __UNIT_TYPE_BIT_COUNT;
            ++buf;
            --count;
        }
        return (0);
    }

    __inline static void __GreatestCommonDivisor(__UNIT_TYPE* u_buf, __UNIT_TYPE u_buf_count, __UNIT_TYPE* v_buf, __UNIT_TYPE v_buf_count, __UNIT_TYPE k, __UNIT_TYPE* w_buf, __UNIT_TYPE w_buf_count)
    {
#ifdef _DEBUG
        if (u_buf_count != v_buf_count)
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic.h;__GreatestCommonDivisor;1");
        if (u_buf_count == 0)
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic.h;__GreatestCommonDivisor;2");
#endif
        __UNIT_TYPE* u = u_buf;
        __UNIT_TYPE* v = v_buf;
        __UNIT_TYPE word_length = u_buf_count;
        for (;;)
        {
            __UNIT_TYPE u_count = __Shrink(u, word_length);
            __UNIT_TYPE v_count = __Shrink(v, word_length);
            word_length = _MAXIMUM_UNIT(u_count, v_count);
#ifdef _DEBUG
            if (word_length <= 0)
            {
                // このルートへの到達はあり得ないはず。
                throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic.h;__GreatestCommonDivisor;3");
            }
#endif
            int c = Compare(u, u_count, v, v_count);
            if (c == 0)
            {
                // u == v の場合

                // u << k を GCD として復帰
                LeftShift(u, u_count, k, w_buf, w_buf_count);
                return;
            }
            if (c < 0)
            {
                {
                    __UNIT_TYPE* t = u;
                    u = v;
                    v = t;
                }
                {
                    __UNIT_TYPE t_count = u_count;
                    u_count = v_count;
                    v_count = t_count;
                }
            }
            // この時点で u > v かつ u と v はともに奇数である

            USubtruct(u, word_length, v, v_count);

            // この時点で u は非ゼロかつ偶数

            // u が奇数になるまで u を右シフトする
            RightShift(u, word_length, __TZCount(u, word_length));
        }
    }

    namespace NDivideExactly
    {

        extern _BYTE_T inverse8_table[128];

        __inline static __UNIT_TYPE GetInverse(__UNIT_TYPE n)
        {
#ifdef _DEBUG
            if ((n & 1) == 0)
                throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic.h;GetInverse;1");
#endif
            _BYTE_T inverse8 = inverse8_table[(n >> 1) & 0x7f];
            _UINT16_T inverse16 = ((_UINT16_T)inverse8 << 1) - (_UINT16_T)inverse8 * inverse8 * (_UINT16_T)n;
#ifdef ENABLED_PERFORMANCE_COUNTER
            AddToDIV32Counter(2);
#endif
            _UINT32_T inverse32 = ((_UINT32_T)inverse16 << 1) - (_UINT32_T)inverse16 * inverse16 * (_UINT32_T)n;
#ifdef ENABLED_PERFORMANCE_COUNTER
            AddToDIV32Counter(2);
#endif
#ifdef _M_IX86
            return (inverse32);
#elif defined(_M_X64)
            _UINT64_T inverse64 = ((_UINT64_T)inverse32 << 1) - (_UINT64_T)inverse32 * inverse32 * (_UINT64_T)n;
#ifdef ENABLED_PERFORMANCE_COUNTER
            AddToDIV64Counter(2);
#endif
            return (inverse64);
#else
#error unknown platform
#endif
        }

        __inline static void DivideExactly_UNIT(__UNIT_TYPE* u_buf, __UNIT_TYPE u_buf_count, __UNIT_TYPE* v_buf, __UNIT_TYPE v_buf_count, __UNIT_TYPE* q_buf, __UNIT_TYPE q_buf_count)
        {
#ifdef _DEBUG
            if (u_buf[u_buf_count - 1] != 0)
            {
                // u_buf の最上位ワードは 0 のはず
                throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic.h;DivideExactly_UNIT;1");
            }
#endif

            __UNIT_TYPE v0 = v_buf[0]; // 除数の最下位桁
            __UNIT_TYPE inverse_v0 = GetInverse(v0); // 除数の最下位桁の逆元

            __UNIT_TYPE q_index = 0;
            while (u_buf_count > v_buf_count + q_index)
            {
                __UNIT_TYPE u0 = u_buf[q_index]; // 被除数の最下位桁
                __UNIT_TYPE temp;
                __UNIT_TYPE q0 = _MULTIPLY_UNIT(u0, inverse_v0, &temp); // 商の最下位桁 (乗算の桁あふれは無視する)
#ifdef ENABLED_PERFORMANCE_COUNTER
                if (sizeof(u0) == sizeof(_UINT64_T))
                    IncrementMULTI64Counter();
                else
                    IncrementMULTI32Counter();
#endif
                // 商と除数の積を被除数から引く
                if (Palmtree::Math::Core::Internal::Basic::NDivRem::MultiplySubtructArray_UNIT(u_buf, u_buf_count, v_buf, v_buf_count, q_index, q0))
                {
                    // 桁借りが発生要因は u が v で割り切れないぐらい・・・のはず
                    throw ArithmeticException(L"完全除算において被除数が除数で割り切れませんでした。");
                }

                // 商を q_buf に追加する
                q_buf[q_index] = q0;
                ++q_index;
            }

            // この時点で u_buf_count == v_buf_count + q_index である
            // u の最上位ワードが 0 かつ v の最上位ワードが 0 で、これ以上は割れないため、除算は終了する。

            // q_buf の余った領域をクリアする
            _ZERO_MEMORY_UNIT(q_buf + q_index, q_buf_count - q_index);

            // 完全除算が割り切れていれば u_buf の上位 u_buf_count 桁がすべて 0 のはずであるが、もしそうではなかったら完全除算は失敗とみなして例外を通知する
            for (__UNIT_TYPE index = q_index; index < u_buf_count; ++index)
            {
                if (u_buf[index] != 0)
                    throw ArithmeticException(L"完全除算において被除数が除数で割り切れませんでした。");
            }
        }

        __inline  static __UNIT_TYPE GetExactDivisionShiftCount(__UNIT_TYPE* u_buf, __UNIT_TYPE u_buf_count, __UNIT_TYPE* v_buf, __UNIT_TYPE v_buf_count)
        {
            for (__UNIT_TYPE index = 0; index < v_buf_count; ++index)
            {
                if (v_buf[index] == 0)
                {
                    if (u_buf[index] == 0)
                    {
                        // continue
                    }
                    else
                    {
                        // v_buf は少なくとも  1 << (index * __UNIT_TYPE_BIT_COUNT) を因数として持つが u_buf はそうではないため、完全除算は成立しない。
                        throw ArithmeticException(L"完全除算において被除数が除数で割り切れませんでした。");
                    }
                }
                else
                {
                    if (u_buf[index] == 0)
                    {
                        __UNIT_TYPE n = _TZCNT_ALT_UNIT(v_buf[index]) + index * __UNIT_TYPE_BIT_COUNT;
                        return (n);
                    }
                    else
                    {
                        __UNIT_TYPE n_u = _TZCNT_ALT_UNIT(u_buf[index]) + index * __UNIT_TYPE_BIT_COUNT;
                        __UNIT_TYPE n_v = _TZCNT_ALT_UNIT(v_buf[index]) + index * __UNIT_TYPE_BIT_COUNT;
                        if (n_u < n_v)
                        {
                            // v_buf は少なくとも  1 << (index * __UNIT_TYPE_BIT_COUNT + n_v) を因数として持つが u_buf はそうではないため、完全除算は成立しない。
                            throw ArithmeticException(L"完全除算において被除数が除数で割り切れませんでした。");
                        }
                        return (n_v);
                    }
                }
            }
            // ここに到達するのは v_buf が 0 の場合だけ
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic.h;GetExactDivisionShiftCount;1");

        }

        __inline static __UNIT_TYPE Shrink1(__UNIT_TYPE* buf, __UNIT_TYPE count)
        {
#ifdef _DEBUG
            if (count < 2 || buf[count - 1] != 0)
                throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic.h;Shrink1;1");
#endif
            while (count > 1 && buf[count - 2] == 0)
                --count;
            return (count);
        }

        __inline static bool MultiplySubtructArray_3_UNIT(__UNIT_TYPE* u_buf, __UNIT_TYPE u_buf_count, __UNIT_TYPE q_index, __UNIT_TYPE q_)
        {
            __UNIT_TYPE mul_hi = q_ >> (__UNIT_TYPE_BIT_COUNT - 1);
            __UNIT_TYPE mul_lo = q_ << 1;
            _ADD_UNIT(_ADD_UNIT(0, mul_lo, q_, &mul_lo), mul_hi, 0, &mul_hi);
            __BORROW_T c;
            c = _SUBTRUCT_UNIT(0, u_buf[q_index], mul_lo, &u_buf[q_index]);
            c = _SUBTRUCT_UNIT(c, u_buf[q_index + 1], mul_hi, &u_buf[q_index + 1]);

            return (Borrow(c, u_buf + (q_index + 2), u_buf_count - (q_index + 2)));
        }

        __inline static void DivideExactlyBy3_UNIT(__UNIT_TYPE* u_buf, __UNIT_TYPE u_buf_count, __UNIT_TYPE* q_buf, __UNIT_TYPE q_buf_count)
        {
            __UNIT_TYPE inverse_v0 = INVERSE_3_MOD_UNIT_TYPE; // 除数の最下位桁の逆元
            __UNIT_TYPE q_index = 0;
            while (u_buf_count > 1 + q_index)
            {
                // MultiplySubtructArray_3_UNITの過程にて、u_buf からの q_index + 2 桁の引き算が発生するので、 u_buf_count >= q_index + 2 である必要がある
                __UNIT_TYPE u0 = u_buf[q_index]; // 被除数の最下位桁
                __UNIT_TYPE temp;
                __UNIT_TYPE q0 = _MULTIPLY_UNIT(u0, inverse_v0, &temp); // 商の最下位桁
#ifdef ENABLED_PERFORMANCE_COUNTER
                if (sizeof(u0) == sizeof(_UINT64_T))
                    IncrementMULTI64Counter();
                else
                    IncrementMULTI32Counter();
#endif
                // 商と除数の積を被除数から引く
                if (MultiplySubtructArray_3_UNIT(u_buf, u_buf_count, q_index, q0))
                {
                    // 桁借りが発生要因は u が v で割り切れないぐらい・・・のはず
                    throw ArithmeticException(L"完全除算において被除数が除数で割り切れませんでした。");
                }
                q_buf[q_index] = q0;
                ++q_index;
            }
            // この時点で u_buf_count == 1 + q_index のはず
            {
                __UNIT_TYPE u0 = u_buf[q_index]; // 被除数の最下位桁
                __UNIT_TYPE r;
                __UNIT_TYPE q0 = _DIVREM_UNIT(0, u0, 3, &r); // 商の最下位桁
#ifdef ENABLED_PERFORMANCE_COUNTER
                if (sizeof(u0) == sizeof(_UINT64_T))
                    IncrementDIV64Counter();
                else
                    IncrementDIV32Counter();
#endif
                if (r != 0)
                    throw ArithmeticException(L"完全除算において被除数が除数で割り切れませんでした。");

                q_buf[q_index] = q0;
                ++q_index;
            }

            // q_buf の余った領域をクリアする
            _ZERO_MEMORY_UNIT(q_buf + q_index, q_buf_count - q_index);
        }

    }

    // q = u / v_buf;
    __inline static void DivideExactly(__UNIT_TYPE u, __UNIT_TYPE* v_buf, __UNIT_TYPE v_buf_count, __UNIT_TYPE& q)
    {
#ifdef _DEBUG
        if (v_buf_count > 0 && v_buf[v_buf_count - 1] == 0)
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic.h;DivideExactly;1");
#endif
        if (v_buf_count == 0)
            throw DivisionByZeroException(L"0による除算が行われようとしました。");
        else if (u == 0)
            q = 0;
        if (1 < v_buf_count)
        {
            // u_buf > 0, v_buf > 0, u_buf < v_buf であり明らかに割り切れないので例外を通知する
            throw ArithmeticException(L"完全除算において被除数が除数で割り切れませんでした。");
        }
        else
        {
            // u_buf >= v_buf である場合

            // u は 1 ワードで表現できるので、v も 1 ワードで表現できる。
            __UNIT_TYPE r;
            q = _DIVREM_UNIT(0, u, v_buf[0], &r);
#ifdef ENABLED_PERFORMANCE_COUNTER
            if (sizeof(u) == sizeof(_UINT64_T))
                IncrementDIV64Counter();
            else
                IncrementDIV32Counter();
#endif
            if (r != 0)
                throw ArithmeticException(L"完全除算において被除数が除数で割り切れませんでした。");
        }
    }

    // q_buf = u_buf / v_buf;
    __inline static void DivideExactly(__UNIT_TYPE* u_buf, __UNIT_TYPE u_buf_count, __UNIT_TYPE* v_buf, __UNIT_TYPE v_buf_count, __UNIT_TYPE* work_u_buf, __UNIT_TYPE work_u_buf_count, __UNIT_TYPE* work_v_buf, __UNIT_TYPE work_v_buf_count, __UNIT_TYPE* q_buf, __UNIT_TYPE q_buf_count)
    {
#ifdef _DEBUG
        if (u_buf_count > 0 && u_buf[u_buf_count - 1] == 0)
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic.h;DivideExactly;1");
        if (v_buf_count > 0 && v_buf[v_buf_count - 1] == 0)
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic.h;DivideExactly;2");
        if (work_u_buf_count < u_buf_count)
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic.h;DivideExactly;3");
        if (work_v_buf_count < v_buf_count)
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic.h;DivideExactly;4");
        if (q_buf_count < u_buf_count - v_buf_count + 2)
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic.h;DivideExactly;5");
#endif
        if (v_buf_count == 0)
            throw DivisionByZeroException(L"0による除算が行われようとしました。");
        else if (u_buf_count == 0)
            _ZERO_MEMORY_UNIT(q_buf, q_buf_count);
        else if (u_buf_count < v_buf_count)
        {
            // u_buf > 0, v_buf > 0, u_buf < v_buf であり明らかに割り切れないので例外を通知する
            throw ArithmeticException(L"完全除算において被除数が除数で割り切れませんでした。");
        }
        else
        {
            __UNIT_TYPE n = NDivideExactly::GetExactDivisionShiftCount(u_buf, u_buf_count, v_buf, v_buf_count);
            // u_buf と v_buf が 少なくとも (1 << n) を共通因数として持つことがわかったので、それぞれ割っておく
            RightShift(u_buf, u_buf_count, n, work_u_buf, work_u_buf_count);
            RightShift(v_buf, v_buf_count, n, work_v_buf, work_v_buf_count);

            // 完全除算を実行する
            NDivideExactly::DivideExactly_UNIT(work_u_buf, NDivideExactly::Shrink1(work_u_buf, work_u_buf_count), work_v_buf, __Shrink(work_v_buf, work_v_buf_count), q_buf, q_buf_count);
        }

    }

    // q_buf = u_buf / 3;
    __inline static void DivideExactlyBy3(__UNIT_TYPE* u_buf, __UNIT_TYPE u_buf_count, __UNIT_TYPE* work_u_buf, __UNIT_TYPE work_u_buf_count, __UNIT_TYPE* q_buf, __UNIT_TYPE q_buf_count)
    {
#ifdef _DEBUG
        if (u_buf_count > 0 && u_buf[u_buf_count - 1] == 0)
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic.h;DivideExactlyBy3;1");
        if (work_u_buf_count < u_buf_count)
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic.h;DivideExactlyBy3;2");
        if (q_buf_count < u_buf_count)
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic.h;DivideExactlyBy3;3");
#endif
        if (u_buf_count == 0)
            _ZERO_MEMORY_UNIT(q_buf, q_buf_count);
        else
        {
            _COPY_MEMORY_UNIT(work_u_buf, u_buf, u_buf_count);
            NDivideExactly::DivideExactlyBy3_UNIT(work_u_buf, u_buf_count, q_buf, q_buf_count);
        }
    }

    // w_buf = GCD(u_buf, v_buf)
    __inline static void GreatestCommonDivisor(__UNIT_TYPE* u_buf, __UNIT_TYPE u_buf_count, __UNIT_TYPE* v_buf, __UNIT_TYPE v_buf_count, __UNIT_TYPE* work_u_buf, __UNIT_TYPE work_u_buf_count, __UNIT_TYPE* work_v_buf, __UNIT_TYPE work_v_buf_count, __UNIT_TYPE* w_buf, __UNIT_TYPE w_buf_count)
    {
#ifdef _DEBUG
        if (u_buf_count > 0 && u_buf[u_buf_count - 1] == 0)
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic.h;GreatestCommonDivisor;1");
        if (v_buf_count > 0 && v_buf[v_buf_count - 1] == 0)
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic.h;GreatestCommonDivisor;2");
        if (work_u_buf_count < _MAXIMUM_UNIT(u_buf_count, v_buf_count))
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic.h;GreatestCommonDivisor;3");
        if (work_v_buf_count < _MAXIMUM_UNIT(u_buf_count, v_buf_count))
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic.h;GreatestCommonDivisor;4");
#endif
        if (u_buf_count == 0)
        {
            if (v_buf_count == 0)
                throw ArithmeticException(L"0 と 0 の GCD は未定義です。");
            else
            {
                _COPY_MEMORY_UNIT(w_buf, v_buf, v_buf_count);
                _ZERO_MEMORY_UNIT(w_buf + v_buf_count, w_buf_count - v_buf_count);
            }
        }
        else
        {
            if (v_buf_count == 0)
            {
                _COPY_MEMORY_UNIT(w_buf, u_buf, u_buf_count);
                _ZERO_MEMORY_UNIT(w_buf + u_buf_count, w_buf_count - u_buf_count);
            }
            else
            {
                __UNIT_TYPE u_buf_tzcnt = __TZCount(u_buf, u_buf_count);
                __UNIT_TYPE v_buf_tzcnt = __TZCount(v_buf, v_buf_count);
                __UNIT_TYPE k = _MINIMUM_UNIT(u_buf_tzcnt, v_buf_tzcnt);
                RightShift(u_buf, u_buf_count, u_buf_tzcnt, work_u_buf, work_u_buf_count);
                RightShift(v_buf, v_buf_count, v_buf_tzcnt, work_v_buf, work_v_buf_count);
                __GreatestCommonDivisor(work_u_buf, work_u_buf_count, work_v_buf, work_v_buf_count, k, w_buf, w_buf_count);
            }
        }
    }

}

#endif

/*
 * END OF FILE
 */