/*
 * The MIT License
 *
 * Copyright 2019 Palmtree Software.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include "pmc_resourceholder_uint.h"
#include "pmc_uint_internal.h"
#include "pmc_autogenerated_inline_func.h"
#include "pmc_basic.h"

#ifdef _M_IX86
#define INVERSE_3_MOD_UNIT_TYPE (2863311531U)
#elif defined(_M_X64)
#define INVERSE_3_MOD_UNIT_TYPE (12297829382473034411U)
#else
#error unknown platform
#endif
namespace Palmtree::Math::Core::Internal
{

    static _BYTE_T inverse8_table[128] =
    {
        1, 171, 205, 183, 57, 163, 197, 239,
        241, 27, 61, 167, 41, 19, 53, 223,
        225, 139, 173, 151, 25, 131, 165, 207,
        209, 251, 29, 135, 9, 243, 21, 191,
        193, 107, 141, 119, 249, 99, 133, 175,
        177, 219, 253, 103, 233, 211, 245, 159,
        161, 75, 109, 87, 217, 67, 101, 143,
        145, 187, 221, 71, 201, 179, 213, 127,
        129, 43, 77, 55, 185, 35, 69, 111,
        113, 155, 189, 39, 169, 147, 181, 95,
        97, 11, 45, 23, 153, 3, 37, 79,
        81, 123, 157, 7, 137, 115, 149, 63,
        65, 235, 13, 247, 121, 227, 5, 47,
        49, 91, 125, 231, 105, 83, 117, 31,
        33, 203, 237, 215, 89, 195, 229, 15,
        17, 59, 93, 199, 73, 51, 85, 255,
    };

#if defined(_MSC_VER) && defined(_M_X64)
    namespace DivRem
    {
        static _UINT64_T _DIVREM_UNIT_1W(_UINT64_T u_hi, _UINT64_T u_lo, _UINT32_T v, _UINT64_T *r)
        {
            _UINT32_T _r;
            _UINT32_T u1;
            _UINT32_T u2 = _FROMDWORDTOWORD(u_hi, &u1);
            _UINT32_T u3;
            _UINT32_T u4 = _FROMDWORDTOWORD(u_lo, &u3);
            _UINT32_T q1;
            _UINT32_T q2;
            _UINT32_T q3;
            _UINT32_T q4;
            _UINT64_T t;

            t = _FROMWORDTODWORD(0, u1);
            q1 = (_UINT32_T)(t / v);
            _r = (_UINT32_T)(t % v);

            t = _FROMWORDTODWORD(_r, u2);
            q2 = (_UINT32_T)(t / v);
            _r = (_UINT32_T)(t % v);

            t = _FROMWORDTODWORD(_r, u3);
            q3 = (_UINT32_T)(t / v);
            _r = (_UINT32_T)(t % v);

            t = _FROMWORDTODWORD(_r, u4);
            q4 = (_UINT32_T)(t / v);
            *r = (_UINT32_T)(t % v);

#ifdef _DEBUG
            {
                if (*r < 0)
                    throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_divrem.cpp;DivRem::_DIVREM_UNIT_1W;1");
                if (*r >= v)
                    throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_divrem.cpp;DivRem::_DIVREM_UNIT_1W;2");
                _UINT64_T temp4 = (_UINT64_T)q4 * v;
                _UINT64_T temp3 = (_UINT64_T)q3 * v;
                _UINT64_T temp2 = (_UINT64_T)q2 * v;
                _UINT64_T temp1 = (_UINT64_T)q1 * v;
                _UINT32_T t_u4;
                _UINT32_T t_u3;
                _UINT32_T t_u2;
                _UINT32_T t_u1;
                _UINT32_T t_u0;
                __CARRY_T carry = 0;
                carry = _addcarry_u32(carry, (_UINT32_T)temp4, (_UINT32_T)*r, &t_u4);
                carry = _addcarry_u32(carry, (_UINT32_T)temp3, (_UINT32_T)(temp4 >> 32), &t_u3);
                carry = _addcarry_u32(carry, (_UINT32_T)temp2, (_UINT32_T)(temp3 >> 32), &t_u2);
                carry = _addcarry_u32(carry, (_UINT32_T)temp1, (_UINT32_T)(temp2 >> 32), &t_u1);
                carry = _addcarry_u32(carry, 0, temp1 >> 32, &t_u0);
                if (carry)
                    throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_divrem.cpp;DivRem::_DIVREM_UNIT_1W;3");
                if (t_u0 != 0)
                    throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_divrem.cpp;DivRem::_DIVREM_UNIT_1W;4");
                if (t_u1 != (u_hi >> 32))
                    throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_divrem.cpp;DivRem::_DIVREM_UNIT_1W;5");
                if (t_u2 != (_UINT32_T)u_hi)
                    throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_divrem.cpp;DivRem::_DIVREM_UNIT_1W;6");
                if (t_u3 != (u_lo >> 32))
                    throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_divrem.cpp;DivRem::_DIVREM_UNIT_1W;7");
                if (t_u4 != (_UINT32_T)u_lo)
                    throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_divrem.cpp;DivRem::_DIVREM_UNIT_1W;8");
            }
#endif

            return (_FROMWORDTODWORD(q3, q4));
        }

        static _UINT32_T _Asume_Q_(_UINT32_T uj, _UINT32_T uj1, _UINT32_T v1)
        {
            return (uj == v1 ? (_UINT32_T)-1 : (_UINT32_T)(_FROMWORDTODWORD(uj, uj1) / v1));
        }

        static int _Check_Q_(_UINT32_T q_, _UINT32_T uj, _UINT32_T uj1, _UINT32_T uj2, _UINT32_T v1, _UINT32_T v2)
        {
            _UINT32_T x1_hi;
            _UINT32_T x1_lo = _FROMDWORDTOWORD((_UINT64_T)v2 * q_, &x1_hi);
            _UINT32_T x2_hi;
            _UINT32_T x2_lo = _FROMDWORDTOWORD((_UINT64_T)v1 * q_, &x2_hi);
            _UINT32_T lh2;
            _UINT32_T lh1;
            _UINT32_T lh0;
            __CARRY_T carry = 0;
            carry = _addcarry_u32(carry, x1_lo, 0, &lh2);
            carry = _addcarry_u32(carry, x1_hi, x2_lo, &lh1);
            carry = _addcarry_u32(carry, 0, x2_hi, &lh0);
            _UINT32_T rh2 = uj2;
            _UINT32_T rh1 = uj1;
            _UINT32_T rh0 = uj;
            if (rh0 != lh0)
                return (lh0 > rh0);
            if (rh1 != lh1)
                return (lh1 > rh1);
            return (lh2 > rh2);
        }

        static _UINT32_T _Calculate_Q_(_UINT32_T uj, _UINT32_T uj1, _UINT32_T uj2, _UINT32_T v1, _UINT32_T v2)
        {
            _UINT32_T q_ = _Asume_Q_(uj, uj1, v1);
            if (_Check_Q_(q_, uj, uj1, uj2, v1, v2))
            {
                --q_;
                if (_Check_Q_(q_, uj, uj1, uj2, v1, v2))
                    --q_;
            }
            return (q_);
        }

        static __BORROW_T _MULTIPLY_SUBTRUCT_UNIT(__BORROW_T c, _UINT32_T* k, _UINT32_T* u, _UINT32_T v, _UINT32_T q_)
        {
            _UINT64_T t = (_UINT64_T)v * q_;
            _UINT32_T t_hi;
            _UINT32_T t_lo = _FROMDWORDTOWORD(t, &t_hi);
            _addcarry_u32(_addcarry_u32(0, t_lo, *k, &t_lo), t_hi, 0, &t_hi);
            c = _subborrow_u32(c, *u, t_lo, u);
            *k = t_hi;
            return (c);
        }

        static _UINT64_T _DIVREM_UNIT_nW(_UINT64_T u_hi, _UINT64_T u_lo, _UINT64_T v, _UINT64_T *r)
        {
#ifdef _DEBUG
            _UINT64_T u_hi_orig = u_hi;
            _UINT64_T u_lo_orig = u_lo;
            _UINT64_T v_orig = v;
#endif

            int d = _LZCNT_ALT_64(v);
            _UINT32_T u0;
            if (d == 0)
            {
                u0 = 0;
            }
            else
            {
                u0 = (_UINT32_T)(u_hi >> (64 - d));
                u_hi = (u_hi << d) | (u_lo >> (64 - d));
                u_lo = u_lo << d;
                v = v << d;
            }
            _UINT32_T u1;
            _UINT32_T u2 = _FROMDWORDTOWORD(u_hi, &u1);
            _UINT32_T u3;
            _UINT32_T u4 = _FROMDWORDTOWORD(u_lo, &u3);
            _UINT32_T v1;
            _UINT32_T v2 = _FROMDWORDTOWORD(v, &v1);
            _UINT32_T q1;
            _UINT32_T q2;
            _UINT32_T q3;
            _UINT32_T q_;

            {
                q_ = _Calculate_Q_(u0, u1, u2, v1, v2);

                _UINT64_T t_hi;
                _UINT64_T t_lo = _umul128(_FROMWORDTODWORD(v1, v2), q_, &t_hi);
                _UINT32_T tt;
                _UINT32_T t0 = _FROMDWORDTOWORD(t_hi, &tt);
                _UINT32_T t1;
                _UINT32_T t2 = _FROMDWORDTOWORD(t_lo, &t1);
                if (tt != 0)
                    throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_divrem.cpp;DivRem::_DIVREM_UNIT_nW;0");
                __BORROW_T borrow = 0;
                borrow = _subborrow_u32(borrow, u2, t2, &u2);
                borrow = _subborrow_u32(borrow, u1, t1, &u1);
                borrow = _subborrow_u32(borrow, u0, t0, &u0);
                if (borrow)
                {
                    __CARRY_T carry = 0;
                    carry = _addcarry_u32(carry, u2, v2, &u2);
                    carry = _addcarry_u32(carry, u1, v1, &u1);
                    carry = _addcarry_u32(carry, u0, 0, &u0);
                    --q_;
                }
                q1 = q_;
                if (u0 > 0)
                    throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_divrem.cpp;DivRem::_DIVREM_UNIT_nW;0");
            }

            {
                q_ = _Calculate_Q_(u1, u2, u3, v1, v2);

                _UINT64_T t_hi;
                _UINT64_T t_lo = _umul128(_FROMWORDTODWORD(v1, v2), q_, &t_hi);
                _UINT32_T tt;
                _UINT32_T t0 = _FROMDWORDTOWORD(t_hi, &tt);
                _UINT32_T t1;
                _UINT32_T t2 = _FROMDWORDTOWORD(t_lo, &t1);
                if (tt != 0)
                    throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_divrem.cpp;DivRem::_DIVREM_UNIT_nW;0");
                __BORROW_T borrow = 0;
                borrow = _subborrow_u32(borrow, u3, t2, &u3);
                borrow = _subborrow_u32(borrow, u2, t1, &u2);
                borrow = _subborrow_u32(borrow, u1, t0, &u1);
                if (borrow)
                {
                    __CARRY_T carry = 0;
                    carry = _addcarry_u32(carry, u3, v2, &u3);
                    carry = _addcarry_u32(carry, u2, v1, &u2);
                    carry = _addcarry_u32(carry, u1, 0, &u1);
                    --q_;
                }
                q2 = q_;
                if (u1 > 0)
                    throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_divrem.cpp;DivRem::_DIVREM_UNIT_nW;0");
            }

            {
                q_ = _Calculate_Q_(u2, u3, u4, v1, v2);

                _UINT64_T t_hi;
                _UINT64_T t_lo = _umul128(_FROMWORDTODWORD(v1, v2), q_, &t_hi);
                _UINT32_T tt;
                _UINT32_T t0 = _FROMDWORDTOWORD(t_hi, &tt);
                _UINT32_T t1;
                _UINT32_T t2 = _FROMDWORDTOWORD(t_lo, &t1);
                if (tt != 0)
                    throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_divrem.cpp;DivRem::_DIVREM_UNIT_nW;0");
                __BORROW_T borrow = 0;
                borrow = _subborrow_u32(borrow, u4, t2, &u4);
                borrow = _subborrow_u32(borrow, u3, t1, &u3);
                borrow = _subborrow_u32(borrow, u2, t0, &u2);
                if (borrow)
                {
                    __CARRY_T carry = 0;
                    carry = _addcarry_u32(carry, u4, v2, &u4);
                    carry = _addcarry_u32(carry, u3, v1, &u3);
                    carry = _addcarry_u32(carry, u2, 0, &u2);
                    --q_;
                }
                q3 = q_;
                if (u2 > 0)
                    throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_divrem.cpp;DivRem::_DIVREM_UNIT_nW;0");
            }

            if (d == 0)
                *r = _FROMWORDTODWORD(u3, u4);
            else
            {

                _UINT32_T r_hi = (u2 << (32 - d)) | (u3 >> d);
                _UINT32_T r_lo = (u3 << (32 - d)) | (u4 >> d);
                *r = _FROMWORDTODWORD(r_hi, r_lo);
            }

#ifdef _DEBUG
            {
                if (*r < 0)
                    throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_divrem.cpp;DivRem::_DIVREM_UNIT_nW;7");
                if (*r >= v_orig)
                    throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_divrem.cpp;DivRem::_DIVREM_UNIT_nW;8");

                // 検算をする

                _UINT64_T q_hi = _FROMWORDTODWORD(0, q1);
                _UINT64_T q_lo = _FROMWORDTODWORD(q2, q3);

                _UINT64_T t1_hi;
                _UINT64_T t1_lo = _umul128(v_orig, q_lo, &t1_hi);
                _UINT64_T t2_hi;
                _UINT64_T t2_lo = _umul128(v_orig, q_hi, &t2_hi);

                _UINT64_T t_vh;
                _UINT64_T t_hi;
                _UINT64_T t_lo;
                __CARRY_T carry = 0;
                carry = _addcarry_u64(carry, t1_lo, *r, &t_lo);
                carry = _addcarry_u64(carry, t1_hi, t2_lo, &t_hi);
                carry = _addcarry_u64(carry, 0, t2_hi, &t_vh);
                if (carry || t_vh > 0)
                    throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_divrem.cpp;DivRem::_DIVREM_UNIT_nW;9");
                if (t_hi != u_hi_orig)
                    throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_divrem.cpp;DivRem::_DIVREM_UNIT_nW;9");
                if (t_lo != u_lo_orig)
                    throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_divrem.cpp;DivRem::_DIVREM_UNIT_nW;9");
            }
#endif
            return (_FROMWORDTODWORD(q2, q3));
        }
    }

    _UINT64_T __DLLEXPORT_DIVREM _DIVREM_UNIT(_UINT64_T u_hi, _UINT64_T u_lo, _UINT64_T v, _UINT64_T *r)
    {
        _UINT32_T v_hi;
        _UINT32_T v_lo = _FROMDWORDTOWORD(v, &v_hi);
        if (v_hi == 0)
        {
            _UINT64_T q = DivRem::_DIVREM_UNIT_1W(u_hi, u_lo, v_lo, r);
            return (q);
        }
        else
        {
            _UINT64_T q = DivRem::_DIVREM_UNIT_nW(u_hi, u_lo, v, r);
            return (q);
        }
    }

    _UINT64_T __DLLEXPORT_DIVREM _DIVREM_SINGLE_UNIT(_UINT64_T r, _UINT64_T u, _UINT64_T v, _UINT64_T *q)
    {
        _UINT64_T RR;
        *q = _DIVREM_UNIT(r, u, v, &RR);
        return (RR);
    }
#endif

    static __UNIT_TYPE Rem_UX_1W(_UBASIC_T u_buf, __UNIT_TYPE v)
    {
        // u の最上位ワードは 0 でありうることに注意すること。
        __UNIT_TYPE* up = u_buf.BLOCK + u_buf.BLOCK_COUNT- 1;
        __UNIT_TYPE u_count = u_buf.BLOCK_COUNT;
        __UNIT_TYPE dummy_q;
        __UNIT_TYPE r = 0;
        __UNIT_TYPE count = u_count >> 5;
        while (count != 0)
        {
            r = _DIVREM_SINGLE_UNIT(r, up[-0], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-1], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-2], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-3], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-4], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-5], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-6], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-7], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-8], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-9], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-10], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-11], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-12], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-13], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-14], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-15], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-16], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-17], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-18], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-19], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-20], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-21], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-22], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-23], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-24], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-25], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-26], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-27], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-28], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-29], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-30], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-31], v, &dummy_q);
            up -= 32;
            --count;
#ifdef ENABLED_PERFORMANCE_COUNTER
            if (sizeof(r) == sizeof(_UINT64_T))
                AddToDIV64Counter(32);
            else
                AddToDIV32Counter(32);
#endif
        }

        if (u_count & 0x10)
        {
            r = _DIVREM_SINGLE_UNIT(r, up[-0], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-1], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-2], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-3], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-4], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-5], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-6], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-7], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-8], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-9], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-10], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-11], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-12], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-13], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-14], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-15], v, &dummy_q);
            up -= 16;
#ifdef ENABLED_PERFORMANCE_COUNTER
            if (sizeof(r) == sizeof(_UINT64_T))
                AddToDIV64Counter(16);
            else
                AddToDIV32Counter(16);
#endif
        }

        if (u_count & 0x8)
        {
            r = _DIVREM_SINGLE_UNIT(r, up[-0], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-1], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-2], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-3], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-4], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-5], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-6], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-7], v, &dummy_q);
            up -= 8;
#ifdef ENABLED_PERFORMANCE_COUNTER
            if (sizeof(r) == sizeof(_UINT64_T))
                AddToDIV64Counter(8);
            else
                AddToDIV32Counter(8);
#endif
        }

        if (u_count & 0x4)
        {
            r = _DIVREM_SINGLE_UNIT(r, up[-0], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-1], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-2], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-3], v, &dummy_q);
            up -= 4;
#ifdef ENABLED_PERFORMANCE_COUNTER
            if (sizeof(r) == sizeof(_UINT64_T))
                AddToDIV64Counter(4);
            else
                AddToDIV32Counter(4);
#endif
        }

        if (u_count & 0x2)
        {
            r = _DIVREM_SINGLE_UNIT(r, up[-0], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-1], v, &dummy_q);
            up -= 2;
#ifdef ENABLED_PERFORMANCE_COUNTER
            if (sizeof(r) == sizeof(_UINT64_T))
                AddToDIV64Counter(2);
            else
                AddToDIV32Counter(2);
#endif
        }

        if (u_count & 0x1)
        {
            r = _DIVREM_SINGLE_UNIT(r, up[-0], v, &dummy_q);
            up -= 1;
#ifdef ENABLED_PERFORMANCE_COUNTER
            if (sizeof(r) == sizeof(_UINT64_T))
                IncrementDIV64Counter();
            else
                IncrementDIV32Counter();
#endif
        }

        return (r);
    }

    static __UNIT_TYPE DivRem_UX_1W(_UBASIC_T u_buf, __UNIT_TYPE v, _UBASIC_T& q_buf)
    {
        q_buf.Region(u_buf.BLOCK_COUNT).Clear();
        __UNIT_TYPE* up = u_buf.BLOCK + u_buf.BLOCK_COUNT - 1;
        __UNIT_TYPE* qp = q_buf.BLOCK + u_buf.BLOCK_COUNT - 1;
        __UNIT_TYPE u_count = u_buf.BLOCK_COUNT;
        __UNIT_TYPE r = 0;
        __UNIT_TYPE count = u_count >> 5;
        while (count != 0)
        {
            r = _DIVREM_SINGLE_UNIT(r, up[-0], v, &qp[-0]);
            r = _DIVREM_SINGLE_UNIT(r, up[-1], v, &qp[-1]);
            r = _DIVREM_SINGLE_UNIT(r, up[-2], v, &qp[-2]);
            r = _DIVREM_SINGLE_UNIT(r, up[-3], v, &qp[-3]);
            r = _DIVREM_SINGLE_UNIT(r, up[-4], v, &qp[-4]);
            r = _DIVREM_SINGLE_UNIT(r, up[-5], v, &qp[-5]);
            r = _DIVREM_SINGLE_UNIT(r, up[-6], v, &qp[-6]);
            r = _DIVREM_SINGLE_UNIT(r, up[-7], v, &qp[-7]);
            r = _DIVREM_SINGLE_UNIT(r, up[-8], v, &qp[-8]);
            r = _DIVREM_SINGLE_UNIT(r, up[-9], v, &qp[-9]);
            r = _DIVREM_SINGLE_UNIT(r, up[-10], v, &qp[-10]);
            r = _DIVREM_SINGLE_UNIT(r, up[-11], v, &qp[-11]);
            r = _DIVREM_SINGLE_UNIT(r, up[-12], v, &qp[-12]);
            r = _DIVREM_SINGLE_UNIT(r, up[-13], v, &qp[-13]);
            r = _DIVREM_SINGLE_UNIT(r, up[-14], v, &qp[-14]);
            r = _DIVREM_SINGLE_UNIT(r, up[-15], v, &qp[-15]);
            r = _DIVREM_SINGLE_UNIT(r, up[-16], v, &qp[-16]);
            r = _DIVREM_SINGLE_UNIT(r, up[-17], v, &qp[-17]);
            r = _DIVREM_SINGLE_UNIT(r, up[-18], v, &qp[-18]);
            r = _DIVREM_SINGLE_UNIT(r, up[-19], v, &qp[-19]);
            r = _DIVREM_SINGLE_UNIT(r, up[-20], v, &qp[-20]);
            r = _DIVREM_SINGLE_UNIT(r, up[-21], v, &qp[-21]);
            r = _DIVREM_SINGLE_UNIT(r, up[-22], v, &qp[-22]);
            r = _DIVREM_SINGLE_UNIT(r, up[-23], v, &qp[-23]);
            r = _DIVREM_SINGLE_UNIT(r, up[-24], v, &qp[-24]);
            r = _DIVREM_SINGLE_UNIT(r, up[-25], v, &qp[-25]);
            r = _DIVREM_SINGLE_UNIT(r, up[-26], v, &qp[-26]);
            r = _DIVREM_SINGLE_UNIT(r, up[-27], v, &qp[-27]);
            r = _DIVREM_SINGLE_UNIT(r, up[-28], v, &qp[-28]);
            r = _DIVREM_SINGLE_UNIT(r, up[-29], v, &qp[-29]);
            r = _DIVREM_SINGLE_UNIT(r, up[-30], v, &qp[-30]);
            r = _DIVREM_SINGLE_UNIT(r, up[-31], v, &qp[-31]);
            up -= 32;
            qp -= 32;
            --count;
#ifdef ENABLED_PERFORMANCE_COUNTER
            if (sizeof(r) == sizeof(_UINT64_T))
                AddToDIV64Counter(32);
            else
                AddToDIV32Counter(32);
#endif
        }

        if (u_count & 0x10)
        {
            r = _DIVREM_SINGLE_UNIT(r, up[-0], v, &qp[-0]);
            r = _DIVREM_SINGLE_UNIT(r, up[-1], v, &qp[-1]);
            r = _DIVREM_SINGLE_UNIT(r, up[-2], v, &qp[-2]);
            r = _DIVREM_SINGLE_UNIT(r, up[-3], v, &qp[-3]);
            r = _DIVREM_SINGLE_UNIT(r, up[-4], v, &qp[-4]);
            r = _DIVREM_SINGLE_UNIT(r, up[-5], v, &qp[-5]);
            r = _DIVREM_SINGLE_UNIT(r, up[-6], v, &qp[-6]);
            r = _DIVREM_SINGLE_UNIT(r, up[-7], v, &qp[-7]);
            r = _DIVREM_SINGLE_UNIT(r, up[-8], v, &qp[-8]);
            r = _DIVREM_SINGLE_UNIT(r, up[-9], v, &qp[-9]);
            r = _DIVREM_SINGLE_UNIT(r, up[-10], v, &qp[-10]);
            r = _DIVREM_SINGLE_UNIT(r, up[-11], v, &qp[-11]);
            r = _DIVREM_SINGLE_UNIT(r, up[-12], v, &qp[-12]);
            r = _DIVREM_SINGLE_UNIT(r, up[-13], v, &qp[-13]);
            r = _DIVREM_SINGLE_UNIT(r, up[-14], v, &qp[-14]);
            r = _DIVREM_SINGLE_UNIT(r, up[-15], v, &qp[-15]);
            up -= 16;
            qp -= 16;
#ifdef ENABLED_PERFORMANCE_COUNTER
            if (sizeof(r) == sizeof(_UINT64_T))
                AddToDIV64Counter(16);
            else
                AddToDIV32Counter(16);
#endif
        }

        if (u_count & 0x8)
        {
            r = _DIVREM_SINGLE_UNIT(r, up[-0], v, &qp[-0]);
            r = _DIVREM_SINGLE_UNIT(r, up[-1], v, &qp[-1]);
            r = _DIVREM_SINGLE_UNIT(r, up[-2], v, &qp[-2]);
            r = _DIVREM_SINGLE_UNIT(r, up[-3], v, &qp[-3]);
            r = _DIVREM_SINGLE_UNIT(r, up[-4], v, &qp[-4]);
            r = _DIVREM_SINGLE_UNIT(r, up[-5], v, &qp[-5]);
            r = _DIVREM_SINGLE_UNIT(r, up[-6], v, &qp[-6]);
            r = _DIVREM_SINGLE_UNIT(r, up[-7], v, &qp[-7]);
            up -= 8;
            qp -= 8;
#ifdef ENABLED_PERFORMANCE_COUNTER
            if (sizeof(r) == sizeof(_UINT64_T))
                AddToDIV64Counter(8);
            else
                AddToDIV32Counter(8);
#endif
        }

        if (u_count & 0x4)
        {
            r = _DIVREM_SINGLE_UNIT(r, up[-0], v, &qp[-0]);
            r = _DIVREM_SINGLE_UNIT(r, up[-1], v, &qp[-1]);
            r = _DIVREM_SINGLE_UNIT(r, up[-2], v, &qp[-2]);
            r = _DIVREM_SINGLE_UNIT(r, up[-3], v, &qp[-3]);
            up -= 4;
            qp -= 4;
#ifdef ENABLED_PERFORMANCE_COUNTER
            if (sizeof(r) == sizeof(_UINT64_T))
                AddToDIV64Counter(4);
            else
                AddToDIV32Counter(4);
#endif
        }

        if (u_count & 0x2)
        {
            r = _DIVREM_SINGLE_UNIT(r, up[-0], v, &qp[-0]);
            r = _DIVREM_SINGLE_UNIT(r, up[-1], v, &qp[-1]);
            up -= 2;
            qp -= 2;
#ifdef ENABLED_PERFORMANCE_COUNTER
            if (sizeof(r) == sizeof(_UINT64_T))
                AddToDIV64Counter(2);
            else
                AddToDIV32Counter(2);
#endif
        }

        if (u_count & 0x1)
        {
            r = _DIVREM_SINGLE_UNIT(r, up[-0], v, &qp[-0]);
            up -= 1;
            qp -= 1;
#ifdef ENABLED_PERFORMANCE_COUNTER
            if (sizeof(r) == sizeof(_UINT64_T))
                IncrementDIV64Counter();
            else
                IncrementDIV32Counter();
#endif
        }

        return (r);
    }

    static __UNIT_TYPE AsumeQ_(__UNIT_TYPE uj, __UNIT_TYPE uj_1, __UNIT_TYPE v1)
    {
        if (uj == v1)
            return (-1);
        __UNIT_TYPE r;
        __UNIT_TYPE q = _DIVREM_UNIT(uj, uj_1, v1, &r);
#ifdef ENABLED_PERFORMANCE_COUNTER
        if (sizeof(v1) == sizeof(_UINT64_T))
            IncrementDIV64Counter();
        else
            IncrementDIV32Counter();
#endif
        return (q);
    }

    static bool CheckQ_(__UNIT_TYPE q_, __UNIT_TYPE uj, __UNIT_TYPE uj_1, __UNIT_TYPE uj_2, __UNIT_TYPE v1, __UNIT_TYPE v2)
    {
        __UNIT_TYPE lh_mi;
        __UNIT_TYPE lh_lo = _MULTIPLY_UNIT(v2, q_, &lh_mi);
        __UNIT_TYPE rh_hi;
        __UNIT_TYPE rh_mi;
        __UNIT_TYPE rh_lo = uj_2;
        __UNIT_TYPE t_hi;
        __UNIT_TYPE t_mi = _MULTIPLY_UNIT(q_, v1, &t_hi);
        _SUBTRUCT_UNIT(_SUBTRUCT_UNIT(0, uj_1, t_mi, &rh_mi), uj, t_hi, &rh_hi);

#ifdef ENABLED_PERFORMANCE_COUNTER
        if (sizeof(q_) == sizeof(_UINT64_T))
            AddToMULTI64Counter(2);
        else
            AddToMULTI32Counter(2);
#endif
        if (rh_hi > 0)
            return (false);
        else if (lh_mi > rh_mi)
            return (true);
        else if (lh_mi < rh_mi)
            return (false);
        else
            return (lh_lo > rh_lo);
    }

    static __UNIT_TYPE CalculateQ_(_UBASIC_T u_buf, _UBASIC_T v_buf, __UNIT_TYPE q_index)
    {
        __UNIT_TYPE u_index = q_index + v_buf.BLOCK_COUNT;
        __UNIT_TYPE uj = u_buf.BLOCK[u_index];
        __UNIT_TYPE uj_1 = u_buf.BLOCK[u_index - 1];
        __UNIT_TYPE uj_2 = u_buf.BLOCK[u_index - 2];
        __UNIT_TYPE v1 = v_buf.BLOCK[v_buf.BLOCK_COUNT - 1];
        __UNIT_TYPE v2 = v_buf.BLOCK[v_buf.BLOCK_COUNT - 2];
        __UNIT_TYPE q_ = AsumeQ_(uj, uj_1, v1);
        if (!CheckQ_(q_, uj, uj_1, uj_2, v1, v2))
            return (q_);
        --q_;
        if (!CheckQ_(q_, uj, uj_1, uj_2, v1, v2))
            return (q_);
        --q_;
        return (q_);
    }

    static bool MultiplySubtructArray_UNIT(BasicOperatorEngine& ep, _UBASIC_T u_buf, _UBASIC_T v_buf, __UNIT_TYPE q_index, __UNIT_TYPE q_)
    {
        __UNIT_TYPE* u_ptr = &u_buf.BLOCK[q_index];
        __UNIT_TYPE* v_ptr = &v_buf.BLOCK[0];
        __UNIT_TYPE v_count = v_buf.BLOCK_COUNT;
        __UNIT_TYPE k = 0;
        __BORROW_T c = 0;

        __UNIT_TYPE count = v_count >> 5;
        while (count != 0)
        {
            c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[0], q_, &u_ptr[0]);
            c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[1], q_, &u_ptr[1]);
            c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[2], q_, &u_ptr[2]);
            c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[3], q_, &u_ptr[3]);
            c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[4], q_, &u_ptr[4]);
            c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[5], q_, &u_ptr[5]);
            c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[6], q_, &u_ptr[6]);
            c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[7], q_, &u_ptr[7]);
            c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[8], q_, &u_ptr[8]);
            c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[9], q_, &u_ptr[9]);
            c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[10], q_, &u_ptr[10]);
            c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[11], q_, &u_ptr[11]);
            c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[12], q_, &u_ptr[12]);
            c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[13], q_, &u_ptr[13]);
            c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[14], q_, &u_ptr[14]);
            c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[15], q_, &u_ptr[15]);
            c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[16], q_, &u_ptr[16]);
            c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[17], q_, &u_ptr[17]);
            c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[18], q_, &u_ptr[18]);
            c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[19], q_, &u_ptr[19]);
            c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[20], q_, &u_ptr[20]);
            c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[21], q_, &u_ptr[21]);
            c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[22], q_, &u_ptr[22]);
            c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[23], q_, &u_ptr[23]);
            c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[24], q_, &u_ptr[24]);
            c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[25], q_, &u_ptr[25]);
            c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[26], q_, &u_ptr[26]);
            c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[27], q_, &u_ptr[27]);
            c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[28], q_, &u_ptr[28]);
            c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[29], q_, &u_ptr[29]);
            c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[30], q_, &u_ptr[30]);
            c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[31], q_, &u_ptr[31]);
            u_ptr += 32;
            v_ptr += 32;
            --count;
#ifdef ENABLED_PERFORMANCE_COUNTER
            if (sizeof(k) == sizeof(_UINT64_T))
                AddToMULTI64Counter(32);
            else
                AddToMULTI32Counter(32);
#endif
        }

        if (v_count & 0x10)
        {
            c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[0], q_, &u_ptr[0]);
            c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[1], q_, &u_ptr[1]);
            c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[2], q_, &u_ptr[2]);
            c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[3], q_, &u_ptr[3]);
            c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[4], q_, &u_ptr[4]);
            c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[5], q_, &u_ptr[5]);
            c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[6], q_, &u_ptr[6]);
            c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[7], q_, &u_ptr[7]);
            c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[8], q_, &u_ptr[8]);
            c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[9], q_, &u_ptr[9]);
            c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[10], q_, &u_ptr[10]);
            c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[11], q_, &u_ptr[11]);
            c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[12], q_, &u_ptr[12]);
            c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[13], q_, &u_ptr[13]);
            c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[14], q_, &u_ptr[14]);
            c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[15], q_, &u_ptr[15]);
            u_ptr += 16;
            v_ptr += 16;
#ifdef ENABLED_PERFORMANCE_COUNTER
            if (sizeof(k) == sizeof(_UINT64_T))
                AddToMULTI64Counter(16);
            else
                AddToMULTI32Counter(16);
#endif
        }

        if (v_count & 0x8)
        {
            c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[0], q_, &u_ptr[0]);
            c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[1], q_, &u_ptr[1]);
            c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[2], q_, &u_ptr[2]);
            c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[3], q_, &u_ptr[3]);
            c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[4], q_, &u_ptr[4]);
            c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[5], q_, &u_ptr[5]);
            c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[6], q_, &u_ptr[6]);
            c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[7], q_, &u_ptr[7]);
            u_ptr += 8;
            v_ptr += 8;
#ifdef ENABLED_PERFORMANCE_COUNTER
            if (sizeof(k) == sizeof(_UINT64_T))
                AddToMULTI64Counter(8);
            else
                AddToMULTI32Counter(8);
#endif
        }

        if (v_count & 0x4)
        {
            c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[0], q_, &u_ptr[0]);
            c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[1], q_, &u_ptr[1]);
            c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[2], q_, &u_ptr[2]);
            c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[3], q_, &u_ptr[3]);
            u_ptr += 4;
            v_ptr += 4;
#ifdef ENABLED_PERFORMANCE_COUNTER
            if (sizeof(k) == sizeof(_UINT64_T))
                AddToMULTI64Counter(4);
            else
                AddToMULTI32Counter(4);
#endif
        }

        if (v_count & 0x2)
        {
            c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[0], q_, &u_ptr[0]);
            c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[1], q_, &u_ptr[1]);
            u_ptr += 2;
            v_ptr += 2;
#ifdef ENABLED_PERFORMANCE_COUNTER
            if (sizeof(k) == sizeof(_UINT64_T))
                AddToMULTI64Counter(2);
            else
                AddToMULTI32Counter(2);
#endif
        }

        if (v_count & 0x1)
        {
            c = _MULTIPLY_SUBTRUCT_UNIT(c, &k, &v_ptr[0], q_, &u_ptr[0]);
            u_ptr += 1;
            v_ptr += 1;
#ifdef ENABLED_PERFORMANCE_COUNTER
            if (sizeof(k) == sizeof(_UINT64_T))
                IncrementMULTI64Counter();
            else
                IncrementMULTI32Counter();
#endif
        }

        c = _SUBTRUCT_UNIT(c, *u_ptr, k, u_ptr);
        u_ptr += 1;

        return (ep.Borrow(c, u_buf.Region(u_ptr - u_buf.BLOCK)));
    }

    static void AddOneLine(BasicOperatorEngine& ep, _UBASIC_T u_buf, _UBASIC_T v_buf, __UNIT_TYPE q_index)
    {
        _UBASIC_T u_buf2(u_buf.BLOCK + q_index, u_buf.BLOCK_COUNT - q_index);
        ep.Add(u_buf2, v_buf, u_buf2);
    }

    static void DivRem_UX_UX_Imp(BasicOperatorEngine& ep, _UBASIC_T u_buf, _UBASIC_T v_buf, _UBASIC_T work_v_buf, _UBASIC_T* q_buf, _UBASIC_T& r_buf)
    {
#ifdef _DEBUG
        if (u_buf.BLOCK_COUNT > 0 && u_buf.BLOCK[u_buf.BLOCK_COUNT - 1] == 0)
            throw InternalErrorException(L"予期しないルートに到達しました。", L"pmc_divrem.cpp;DivRem_UX_UX_Imp;1");
        if (v_buf.BLOCK_COUNT > 0 && v_buf.BLOCK[v_buf.BLOCK_COUNT - 1] == 0)
            throw InternalErrorException(L"予期しないルートに到達しました。", L"pmc_divrem.cpp;DivRem_UX_UX_Imp;2");
        if (u_buf.BLOCK_COUNT < v_buf.BLOCK_COUNT)
            throw InternalErrorException(L"予期しないルートに到達しました。", L"pmc_divrem.cpp;DivRem_UX_UX_Imp;3");
        if (r_buf.BLOCK_COUNT < u_buf.BLOCK_COUNT)
            throw InternalErrorException(L"予期しないルートに到達しました。", L"pmc_divrem.cpp;DivRem_UX_UX_Imp;4");
        if (q_buf != nullptr)
        {
            if (u_buf.BLOCK_COUNT - v_buf.BLOCK_COUNT >= q_buf->BLOCK_COUNT)
                throw InternalErrorException(L"予期しないルートに到達しました。", L"pmc_divrem.cpp;DivRem_UX_UX_Imp;5");
        }
#endif

        r_buf.Region(u_buf.BLOCK_COUNT).Clear();
        __UNIT_TYPE d_factor = _LZCNT_ALT_UNIT(v_buf.BLOCK[v_buf.BLOCK_COUNT - 1]);
        ep.LeftShift(u_buf, d_factor, r_buf);
        ep.LeftShift(v_buf, d_factor, work_v_buf);

        if (q_buf != nullptr)
            _ZERO_MEMORY_UNIT(q_buf->BLOCK + (u_buf.BLOCK_COUNT - v_buf.BLOCK_COUNT + 1), q_buf->BLOCK_COUNT - (u_buf.BLOCK_COUNT - v_buf.BLOCK_COUNT + 1));
        __UNIT_TYPE q_index = u_buf.BLOCK_COUNT - v_buf.BLOCK_COUNT;

        for (;;)
        {
            __UNIT_TYPE q_ = CalculateQ_(r_buf, work_v_buf, q_index);


            if (MultiplySubtructArray_UNIT(ep, r_buf, work_v_buf, q_index, q_))
            {
                // 桁借りが発生した場合
                --q_;
                AddOneLine(ep, r_buf, work_v_buf, q_index);
            }

            if (q_buf != nullptr)
                q_buf->BLOCK[q_index] = q_;
            if (q_index == 0)
                break;
            --q_index;
        }

        ep.RightShift(r_buf, d_factor);
    }

    void BasicOperatorEngine::DivRem(_UBASIC_T u_buf, __UNIT_TYPE v, _UBASIC_T q_buf, __UNIT_TYPE& r)
    {
#ifdef _DEBUG
        if (u_buf.BLOCK_COUNT > 0 && u_buf.BLOCK[u_buf.BLOCK_COUNT - 1] == 0)
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic_divrem.cpp;BasicOperatorEngine::DivRem;1");
#endif
        if (v == 0)
            throw DivisionByZeroException(L"0による除算が行われようとしました。");
        else if (u_buf.BLOCK_COUNT == 0)
        {
            q_buf.Clear();
            r = 0;
        }
        else if (u_buf.BLOCK_COUNT == 1)
        {
#ifdef _DEBUG
            if (q_buf.BLOCK_COUNT < 1)
                throw InternalErrorException(L"予期しないルートに到達しました。", L"pmc_divrem.cpp;BasicOperatorEngine::DivRem;2");
#endif
            __UNIT_TYPE q = _DIVREM_UNIT(0, u_buf.BLOCK[0], v, &r);
#ifdef ENABLED_PERFORMANCE_COUNTER
            if (sizeof(r) == sizeof(_UINT64_T))
                IncrementDIV64Counter();
            else
                IncrementDIV32Counter();
#endif
            q_buf.BLOCK[0] = q;
            q_buf.Region(1).Clear();
        }
        else
            r = DivRem_UX_1W(u_buf, v, q_buf);
    }

    void BasicOperatorEngine::DivRem(__UNIT_TYPE u, _UBASIC_T v_buf, __UNIT_TYPE& q, __UNIT_TYPE& r)
    {
#ifdef _DEBUG
        if (v_buf.BLOCK_COUNT > 0 && v_buf.BLOCK[v_buf.BLOCK_COUNT - 1] == 0)
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic_bitwiseand.cpp;BasicOperatorEngine::BitwiseAnd;2");
#endif
        if (v_buf.BLOCK_COUNT == 0)
            throw DivisionByZeroException(L"0による除算が行われようとしました。");
        else if (u == 0 || 1 < v_buf.BLOCK_COUNT)
        {
            q = 0;
            r = u;
        }
        else
        {
            q = _DIVREM_UNIT(0, u, v_buf.BLOCK[0], &r);
#ifdef ENABLED_PERFORMANCE_COUNTER
            if (sizeof(r) == sizeof(_UINT64_T))
                IncrementDIV64Counter();
            else
                IncrementDIV32Counter();
#endif
        }
    }

    void BasicOperatorEngine::DivRem(_UBASIC_T u_buf, _UBASIC_T v_buf, _UBASIC_T work_v_buf, _UBASIC_T q_buf, _UBASIC_T r_buf)
    {
#ifdef _DEBUG
        if (u_buf.BLOCK_COUNT > 0 && u_buf.BLOCK[u_buf.BLOCK_COUNT - 1] == 0)
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic_bitwiseand.cpp;BasicOperatorEngine::BitwiseAnd;1");
        if (v_buf.BLOCK_COUNT > 0 && v_buf.BLOCK[v_buf.BLOCK_COUNT - 1] == 0)
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic_bitwiseand.cpp;BasicOperatorEngine::BitwiseAnd;2");
#endif
        if (v_buf.BLOCK_COUNT == 0)
            throw DivisionByZeroException(L"0による除算が行われようとしました。");
        else if (v_buf.BLOCK_COUNT == 1)
        {
            if (u_buf.BLOCK_COUNT == 0)
            {
                q_buf.Clear();
                r_buf.Clear();
            }
            else if (u_buf.BLOCK_COUNT == 1)
            {
#ifdef _DEBUG
                if (q_buf.BLOCK_COUNT < 1)
                    throw InternalErrorException(L"予期しないルートに到達しました。", L"pmc_divrem.cpp;DivRem_UX_UX;1");
                if (r_buf.BLOCK_COUNT < 1)
                    throw InternalErrorException(L"予期しないルートに到達しました。", L"pmc_divrem.cpp;DivRem_UX_UX;2");
#endif
                __UNIT_TYPE r;
                __UNIT_TYPE q = _DIVREM_UNIT(0, u_buf.BLOCK[0], v_buf.BLOCK[0], &r);
#ifdef ENABLED_PERFORMANCE_COUNTER
                if (sizeof(r) == sizeof(_UINT64_T))
                    IncrementDIV64Counter();
                else
                    IncrementDIV32Counter();
#endif
                q_buf.BLOCK[0] = q;
                q_buf.Region(1).Clear();
                r_buf.BLOCK[0] = r;
                r_buf.Region(1).Clear();
            }
            else
            {
#ifdef _DEBUG
                if (r_buf.BLOCK_COUNT < 1)
                    throw InternalErrorException(L"予期しないルートに到達しました。", L"pmc_divrem.cpp;DivRem_UX_UX;3");
#endif
                r_buf.BLOCK[0] = DivRem_UX_1W(u_buf, v_buf.BLOCK[0], q_buf);
                r_buf.Region(1).Clear();
            }
        }
        else
        {
            if (u_buf.BLOCK_COUNT < v_buf.BLOCK_COUNT)
            {
                q_buf.Clear();
                r_buf.CopyFrom(u_buf);
            }
            else
                DivRem_UX_UX_Imp(*this, u_buf, v_buf, work_v_buf, &q_buf, r_buf);
        }
    }

    void BasicOperatorEngine::Remainder(_UBASIC_T u_buf, __UNIT_TYPE v, __UNIT_TYPE & r)
    {
#ifdef _DEBUG
        if (u_buf.BLOCK_COUNT > 0 && u_buf.BLOCK[u_buf.BLOCK_COUNT - 1] == 0)
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic_divrem.cpp;BasicOperatorEngine::DivRem;1");
#endif
        if (v == 0)
            throw DivisionByZeroException(L"0による除算が行われようとしました。");
        else if (u_buf.BLOCK_COUNT == 0)
            r = 0;
        else if (u_buf.BLOCK_COUNT == 1)
        {
            _DIVREM_UNIT(0, u_buf.BLOCK[0], v, &r);
#ifdef ENABLED_PERFORMANCE_COUNTER
            if (sizeof(r) == sizeof(_UINT64_T))
                IncrementDIV64Counter();
            else
                IncrementDIV32Counter();
#endif
        }
        else
            r = Rem_UX_1W(u_buf, v);
    }

    void BasicOperatorEngine::Remainder(__UNIT_TYPE u, _UBASIC_T v_buf, __UNIT_TYPE& r)
    {
#ifdef _DEBUG
        if (v_buf.BLOCK_COUNT > 0 && v_buf.BLOCK[v_buf.BLOCK_COUNT - 1] == 0)
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic_bitwiseand.cpp;BasicOperatorEngine::BitwiseAnd;2");
#endif
        if (v_buf.BLOCK_COUNT == 0)
            throw DivisionByZeroException(L"0による除算が行われようとしました。");
        else if (u == 0 || 1 < v_buf.BLOCK_COUNT)
            r = u;
        else
        {
            _DIVREM_UNIT(0, u, v_buf.BLOCK[0], &r);
#ifdef ENABLED_PERFORMANCE_COUNTER
            if (sizeof(r) == sizeof(_UINT64_T))
                IncrementDIV64Counter();
            else
                IncrementDIV32Counter();
#endif
        }
    }

    void BasicOperatorEngine::Remainder(_UBASIC_T u_buf, _UBASIC_T v_buf, _UBASIC_T work_v_buf, _UBASIC_T r_buf)
    {
#ifdef _DEBUG
        if (u_buf.BLOCK_COUNT > 0 && u_buf.BLOCK[u_buf.BLOCK_COUNT - 1] == 0)
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic_bitwiseand.cpp;BasicOperatorEngine::BitwiseAnd;1");
        if (v_buf.BLOCK_COUNT > 0 && v_buf.BLOCK[v_buf.BLOCK_COUNT - 1] == 0)
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic_bitwiseand.cpp;BasicOperatorEngine::BitwiseAnd;2");
#endif
        if (v_buf.BLOCK_COUNT == 0)
            throw DivisionByZeroException(L"0による除算が行われようとしました。");
        else if (v_buf.BLOCK_COUNT == 1)
        {
            if (u_buf.BLOCK_COUNT == 0)
                r_buf.Clear();
            else if (u_buf.BLOCK_COUNT == 1)
            {
#ifdef _DEBUG
                if (r_buf.BLOCK_COUNT < 1)
                    throw InternalErrorException(L"予期しないルートに到達しました。", L"pmc_divrem.cpp;DivRem_UX_UX;2");
#endif
                __UNIT_TYPE r;
                _DIVREM_UNIT(0, u_buf.BLOCK[0], v_buf.BLOCK[0], &r);
#ifdef ENABLED_PERFORMANCE_COUNTER
                if (sizeof(r) == sizeof(_UINT64_T))
                    IncrementDIV64Counter();
                else
                    IncrementDIV32Counter();
#endif
                r_buf.BLOCK[0] = r;
                r_buf.Region(1).Clear();
            }
            else
            {
#ifdef _DEBUG
                if (r_buf.BLOCK_COUNT < 1)
                    throw InternalErrorException(L"予期しないルートに到達しました。", L"pmc_divrem.cpp;DivRem_UX_UX;3");
#endif
                r_buf.BLOCK[0] = Rem_UX_1W(u_buf, v_buf.BLOCK[0]);
                r_buf.Region(1).Clear();
            }
        }
        else
        {
            if (u_buf.BLOCK_COUNT < v_buf.BLOCK_COUNT)
                r_buf.CopyFrom(u_buf);
            else
                DivRem_UX_UX_Imp(*this, u_buf, v_buf, work_v_buf, nullptr, r_buf);
        }
    }

    static __UNIT_TYPE GetInverse(__UNIT_TYPE n)
    {
#ifdef _DEBUG
        if ((n & 1) == 0)
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic_divrem.cpp;GetInverse;1");
#endif
        _BYTE_T inverse8 = inverse8_table[(n >> 1) & 0x7f];
        _UINT16_T inverse16 = ((_UINT16_T)inverse8 << 1) - (_UINT16_T)inverse8 * inverse8 * (_UINT16_T)n;
#ifdef ENABLED_PERFORMANCE_COUNTER
        AddToDIV32Counter(2);
#endif
        _UINT32_T inverse32 = ((_UINT32_T)inverse16 << 1) - (_UINT32_T)inverse16 * inverse16 * (_UINT32_T)n;
#ifdef ENABLED_PERFORMANCE_COUNTER
        AddToDIV32Counter(2);
#endif
#ifdef _M_IX86
        return (inverse32);
#elif defined(_M_X64)
        _UINT64_T inverse64 = ((_UINT64_T)inverse32 << 1) - (_UINT64_T)inverse32 * inverse32 * (_UINT64_T)n;
#ifdef ENABLED_PERFORMANCE_COUNTER
        AddToDIV64Counter(2);
#endif
        return (inverse64);
#else
#error unknown platform
#endif
    }

    static void DivideExactly_UNIT(BasicOperatorEngine& ep, _UBASIC_T u_buf, _UBASIC_T v_buf, _UBASIC_T q_buf)
    {
#ifdef _DEBUG
        if (u_buf.BLOCK[u_buf.BLOCK_COUNT - 1] != 0)
        {
            // u_buf の最上位ワードは 0 のはず
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic_divrem.cpp;DivideExactly_UNIT;1");
        }
#endif

        __UNIT_TYPE v0 = v_buf.BLOCK[0]; // 除数の最下位桁
        __UNIT_TYPE inverse_v0 = GetInverse(v0); // 除数の最下位桁の逆元

        __UNIT_TYPE q_index = 0;
        while (u_buf.BLOCK_COUNT > v_buf.BLOCK_COUNT + q_index)
        {
            __UNIT_TYPE u0 = u_buf.BLOCK[q_index]; // 被除数の最下位桁
            __UNIT_TYPE temp;
            __UNIT_TYPE q0 = _MULTIPLY_UNIT(u0, inverse_v0, &temp); // 商の最下位桁 (乗算の桁あふれは無視する)
#ifdef ENABLED_PERFORMANCE_COUNTER
            if (sizeof(u0) == sizeof(_UINT64_T))
                IncrementMULTI64Counter();
            else
                IncrementMULTI32Counter();
#endif
            // 商と除数の積を被除数から引く
            if (MultiplySubtructArray_UNIT(ep, u_buf, v_buf, q_index, q0))
            {
                // 桁借りが発生要因は u が v で割り切れないぐらい・・・のはず
                throw ArithmeticException(L"完全除算において被除数が除数で割り切れませんでした。");
            }

            // 商を q_buf に追加する
            q_buf.BLOCK[q_index] = q0;
            ++q_index;
        }

        // この時点で u_buf_count == v_buf_count + q_index である
        // u の最上位ワードが 0 かつ v の最上位ワードが 0 で、これ以上は割れないため、除算は終了する。

        // q_buf の余った領域をクリアする
        q_buf.Region(q_index).Clear();

        // 完全除算が割り切れていれば u_buf の上位 u_buf.BLOCK_COUNT 桁がすべて 0 のはずであるが、もしそうではなかったら完全除算は失敗とみなして例外を通知する
        for (__UNIT_TYPE index = q_index; index < u_buf.BLOCK_COUNT; ++index)
        {
            if (u_buf.BLOCK[index] != 0)
                throw ArithmeticException(L"完全除算において被除数が除数で割り切れませんでした。");
        }
    }

    static __UNIT_TYPE GetExactDivisionShiftCount(_UBASIC_T u_buf, _UBASIC_T v_buf)
    {
        for (__UNIT_TYPE index = 0; index < v_buf.BLOCK_COUNT; ++index)
        {
            if (v_buf.BLOCK[index] == 0)
            {
                if (u_buf.BLOCK[index] == 0)
                {
                    // continue
                }
                else
                {
                    // v_buf は少なくとも  1 << (index * __UNIT_TYPE_BIT_COUNT) を因数として持つが u_buf はそうではないため、完全除算は成立しない。
                    throw ArithmeticException(L"完全除算において被除数が除数で割り切れませんでした。");
                }
            }
            else
            {
                if (u_buf.BLOCK[index] == 0)
                {
                    __UNIT_TYPE n = _TZCNT_ALT_UNIT(v_buf.BLOCK[index]) + index * __UNIT_TYPE_BIT_COUNT;
                    return (n);
                }
                else
                {
                    __UNIT_TYPE n_u = _TZCNT_ALT_UNIT(u_buf.BLOCK[index]) + index * __UNIT_TYPE_BIT_COUNT;
                    __UNIT_TYPE n_v = _TZCNT_ALT_UNIT(v_buf.BLOCK[index]) + index * __UNIT_TYPE_BIT_COUNT;
                    if (n_u < n_v)
                    {
                        // v_buf は少なくとも  1 << (index * __UNIT_TYPE_BIT_COUNT + n_v) を因数として持つが u_buf はそうではないため、完全除算は成立しない。
                        throw ArithmeticException(L"完全除算において被除数が除数で割り切れませんでした。");
                    }
                    return (n_v);
                }
            }
        }
        // ここに到達するのは v_buf が 0 の場合だけ
        throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic_divrem.cpp;GetExactDivisionShiftCount;1");

    }

    void BasicOperatorEngine::DivideExactly(__UNIT_TYPE u, _UBASIC_T v_buf, __UNIT_TYPE & q)
    {
#ifdef _DEBUG
        if (v_buf.BLOCK_COUNT > 0 && v_buf.BLOCK[v_buf.BLOCK_COUNT - 1] == 0)
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic_divrem.cpp;BasicOperatorEngine::DivideExactly;2");
#endif
        if (v_buf.BLOCK_COUNT == 0)
            throw DivisionByZeroException(L"0による除算が行われようとしました。");
        else if (u == 0)
            q = 0;
        if (1 < v_buf.BLOCK_COUNT)
        {
            // u_buf > 0, v_buf > 0, u_buf < v_buf であり明らかに割り切れないので例外を通知する
            throw ArithmeticException(L"完全除算において被除数が除数で割り切れませんでした。");
        }
        else
        {
            // u_buf >= v_buf である場合

            // u は 1 ワードで表現できるので、v も 1 ワードで表現できる。
            __UNIT_TYPE r;
            q = _DIVREM_UNIT(0, u, v_buf.BLOCK[0], &r);
#ifdef ENABLED_PERFORMANCE_COUNTER
            if (sizeof(u) == sizeof(_UINT64_T))
                IncrementDIV64Counter();
            else
                IncrementDIV32Counter();
#endif
            if (r != 0)
                throw ArithmeticException(L"完全除算において被除数が除数で割り切れませんでした。");
        }
    }

    void BasicOperatorEngine::DivideExactly(_UBASIC_T u_buf, _UBASIC_T v_buf, _UBASIC_T work_u_buf, _UBASIC_T work_v_buf, _UBASIC_T q_buf)
    {
#ifdef _DEBUG
        if (u_buf.BLOCK_COUNT > 0 && u_buf.BLOCK[u_buf.BLOCK_COUNT - 1] == 0)
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic_divrem.cpp;BasicOperatorEngine::DivideExactly;1");
        if (v_buf.BLOCK_COUNT > 0 && v_buf.BLOCK[v_buf.BLOCK_COUNT - 1] == 0)
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic_divrem.cpp;BasicOperatorEngine::DivideExactly;2");
        if (work_u_buf.BLOCK_COUNT < u_buf.BLOCK_COUNT)
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic_divrem.cpp;BasicOperatorEngine::DivideExactly;4");
        if (work_v_buf.BLOCK_COUNT < v_buf.BLOCK_COUNT)
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic_divrem.cpp;BasicOperatorEngine::DivideExactly;5");
        if (q_buf.BLOCK_COUNT < u_buf.BLOCK_COUNT - v_buf.BLOCK_COUNT + 2)
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic_divrem.cpp;BasicOperatorEngine::DivideExactly;6");
#endif
        if (v_buf.BLOCK_COUNT == 0)
            throw DivisionByZeroException(L"0による除算が行われようとしました。");
        else if (u_buf.BLOCK_COUNT == 0)
            q_buf.Clear();
        else if (u_buf.BLOCK_COUNT < v_buf.BLOCK_COUNT)
        {
            // u_buf > 0, v_buf > 0, u_buf < v_buf であり明らかに割り切れないので例外を通知する
            throw ArithmeticException(L"完全除算において被除数が除数で割り切れませんでした。");
        }
        else
        {
            __UNIT_TYPE n = GetExactDivisionShiftCount(u_buf, v_buf);
            // u_buf と v_buf が 少なくとも (1 << n) を共通因数として持つことがわかったので、それぞれ割っておく
            RightShift(u_buf, n, work_u_buf);
            RightShift(v_buf, n, work_v_buf);

            // 完全除算を実行する
            DivideExactly_UNIT(*this, work_u_buf.Shrink1(), work_v_buf.Shrink(), q_buf);
        }

    }

    static bool MultiplySubtructArray_3_UNIT(BasicOperatorEngine& ep, _UBASIC_T u_buf, __UNIT_TYPE q_index, __UNIT_TYPE q_)
    {
        __UNIT_TYPE mul_hi = q_ >> (__UNIT_TYPE_BIT_COUNT - 1);
        __UNIT_TYPE mul_lo = q_ << 1;
        _ADD_UNIT(_ADD_UNIT(0, mul_lo, q_, &mul_lo), mul_hi, 0, &mul_hi);
        __BORROW_T c;
        c = _SUBTRUCT_UNIT(0, u_buf.BLOCK[q_index], mul_lo, &u_buf.BLOCK[q_index]);
        c = _SUBTRUCT_UNIT(c, u_buf.BLOCK[q_index + 1], mul_hi, &u_buf.BLOCK[q_index + 1]);

        return (ep.Borrow(c, u_buf.Region(q_index + 2)));
    }

    static void DivideExactlyBy3_UNIT(BasicOperatorEngine& ep, _UBASIC_T u_buf, _UBASIC_T& q_buf)
    {
        __UNIT_TYPE inverse_v0 = INVERSE_3_MOD_UNIT_TYPE; // 除数の最下位桁の逆元
        __UNIT_TYPE q_index = 0;
        while (u_buf.BLOCK_COUNT > 1 + q_index)
        {
            // MultiplySubtructArray_3_UNITの過程にて、u_buf からの q_index + 2 桁の引き算が発生するので、 u_buf_count >= q_index + 2 である必要がある
            __UNIT_TYPE u0 = u_buf.BLOCK[q_index]; // 被除数の最下位桁
            __UNIT_TYPE temp;
            __UNIT_TYPE q0 = _MULTIPLY_UNIT(u0, inverse_v0, &temp); // 商の最下位桁
#ifdef ENABLED_PERFORMANCE_COUNTER
            if (sizeof(u0) == sizeof(_UINT64_T))
                IncrementMULTI64Counter();
            else
                IncrementMULTI32Counter();
#endif
            // 商と除数の積を被除数から引く
            if (MultiplySubtructArray_3_UNIT(ep, u_buf, q_index, q0))
            {
                // 桁借りが発生要因は u が v で割り切れないぐらい・・・のはず
                throw ArithmeticException(L"完全除算において被除数が除数で割り切れませんでした。");
            }
            q_buf.BLOCK[q_index] = q0;
            ++q_index;
        }
        // この時点で u_buf_count == 1 + q_index のはず
        {
            __UNIT_TYPE u0 = u_buf.BLOCK[q_index]; // 被除数の最下位桁
            __UNIT_TYPE r;
            __UNIT_TYPE q0 = _DIVREM_UNIT(0, u0, 3, &r); // 商の最下位桁
#ifdef ENABLED_PERFORMANCE_COUNTER
            if (sizeof(u0) == sizeof(_UINT64_T))
                IncrementDIV64Counter();
            else
                IncrementDIV32Counter();
#endif
            if (r != 0)
                throw ArithmeticException(L"完全除算において被除数が除数で割り切れませんでした。");

            q_buf.BLOCK[q_index] = q0;
            ++q_index;
        }

        // q_buf の余った領域をクリアする
        q_buf.Region(q_index).Clear();
    }

    void BasicOperatorEngine::DivideExactlyBy3(_BASIC_T & u_buf, _UBASIC_T work_u_buf)
    {
        work_u_buf.CopyFrom(u_buf.ABS);
        DivideExactlyBy3_UNIT(*this, work_u_buf, u_buf.ABS);
    }

    void BasicOperatorEngine::DivideExactlyBy3(_UBASIC_T u_buf, _UBASIC_T work_u_buf, _UBASIC_T q_buf)
    {
#ifdef _DEBUG
        if (u_buf.BLOCK_COUNT > 0 && u_buf.BLOCK[u_buf.BLOCK_COUNT - 1] == 0)
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic_divrem.cpp;BasicOperatorEngine::DivideExactlyBy3;1");
        if (work_u_buf.BLOCK_COUNT < u_buf.BLOCK_COUNT)
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic_divrem.cpp;BasicOperatorEngine::DivideExactlyBy3;2");
        if (q_buf.BLOCK_COUNT < u_buf.BLOCK_COUNT)
            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_basic_divrem.cpp;BasicOperatorEngine::DivideExactlyBy3;3");
#endif
        if (u_buf.BLOCK_COUNT == 0)
            q_buf.Clear();
        else
        {
            work_u_buf.CopyFrom(u_buf);
            DivideExactlyBy3_UNIT(*this, work_u_buf, q_buf);
        }
    }

}


/*
 * END OF FILE
 */