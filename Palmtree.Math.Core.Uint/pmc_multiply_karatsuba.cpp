/*
 * The MIT License
 *
 * Copyright 2019 Palmtree Software.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */


#ifdef _DEBUG
#include <iostream>
#endif
#include "pmc_multiply_karatsuba.h"
#include "pmc_multiply_classic.h"
#include "pmc_resourceholder_uint.h"
#include "pmc_exception.h"
#include "autogenerated_inline_func.h"

#ifdef _M_IX86
#define LOG2_N_THRESHOLD_CLASSIC    (11) // log2_n がこの値未満ならば classic法 に切り替える
#elif defined(_M_X64)
#define LOG2_N_THRESHOLD_CLASSIC    (11) // log2_n がこの値未満ならば classic法 に切り替える
#else
#error unknown platform
#endif

#define ENABLED_KARATSUBA2 (true)
#define ENABLED_KARATSUBA3 (true)

namespace Palmtree::Math::Core::Internal
{
    static const size_t size_t_max = (size_t)-1 / 2; // OS のユーザメモリ空間の最大サイズ

    static SIGN_T Compare_UX_UX(__UNIT_TYPE count, __UNIT_TYPE* u, __UNIT_TYPE* v)
    {
        u += count;
        v += count;
        while (count > 0)
        {
            --u;
            --v;
            --count;

            if (*u > *v)
                return (SIGN_POSITIVE);
            else if (*u < *v)
                return (SIGN_NEGATIVE);
            else
            {
            }
        }
        return (SIGN_ZERO);
    }

    static char Add_UX_UX(__UNIT_TYPE n, __UNIT_TYPE* u_buf, __UNIT_TYPE* v_buf, __UNIT_TYPE* w_buf)
    {
        __UNIT_TYPE* up = u_buf;
        __UNIT_TYPE* vp = v_buf;
        __UNIT_TYPE* wp = w_buf;
        char c = 0;

        // まず 32 ワードずつ加算をする。
        __UNIT_TYPE count = n >> 5;
        while (count != 0)
        {
            c = _ADD_32WORDS_ADC(c, up, vp, wp);
            up += 32;
            vp += 32;
            wp += 32;
            --count;
        }
        // この時点で未処理の桁は 32 ワード未満のはず

        // 未処理の桁が 16 ワード以上あるなら 16 ワード加算を行う。
        if (n & 0x10)
        {
            c = _ADD_16WORDS_ADC(c, up, vp, wp);
            up += 16;
            vp += 16;
            wp += 16;
        }
        // この時点で未処理の桁は 16 ワード未満のはず

        // 未処理の桁が 8 ワード以上あるなら 8 ワード加算を行う。
        if (n & 0x8)
        {
            c = _ADD_8WORDS_ADC(c, up, vp, wp);
            up += 8;
            vp += 8;
            wp += 8;
        }
        // この時点で未処理の桁は 8 ワード未満のはず

        // 未処理の桁が 4 ワード以上あるなら 4 ワード加算を行う。
        if (n & 0x4)
        {
            c = _ADD_4WORDS_ADC(c, up, vp, wp);
            up += 4;
            vp += 4;
            wp += 4;
        }
        // この時点で未処理の桁は 4 ワード未満のはず

        // 未処理の桁が 2 ワード以上あるなら 2 ワード加算を行う。
        if (n & 0x2)
        {
            c = _ADD_2WORDS_ADC(c, up, vp, wp);
            up += 2;
            vp += 2;
            wp += 2;
        }
        // この時点で未処理の桁は 2 ワード未満のはず

        // 未処理の桁が 1 ワード以上あるなら 1 ワード加算を行う。
        if (n & 0x1)
            c = _ADD_UNIT(c, *up++, *vp++, wp++);

        return (c);
    }

    static char Subtruct_UX_UX(__UNIT_TYPE n, __UNIT_TYPE* up, __UNIT_TYPE* vp, __UNIT_TYPE* wp)
    {
        char c = 0;

        // まず 32 ワードずつ減算をする。
        __UNIT_TYPE count = n >> 5;
        while (count != 0)
        {
            c = _SUBTRUCT_32WORDS_SBB(c, up, vp, wp);
            up += 32;
            vp += 32;
            wp += 32;
            --count;
        }
        // この時点で未処理の桁は 32 ワード未満のはず

        // 未処理の桁が 16 ワード以上あるなら 16 ワード減算を行う。
        if (n & 0x10)
        {
            c = _SUBTRUCT_16WORDS_SBB(c, up, vp, wp);
            up += 16;
            vp += 16;
            wp += 16;
        }
        // この時点で未処理の桁は 16 ワード未満のはず

        // 未処理の桁が 8 ワード以上あるなら 8 ワード減算を行う。
        if (n & 0x8)
        {
            c = _SUBTRUCT_8WORDS_SBB(c, up, vp, wp);
            up += 8;
            vp += 8;
            wp += 8;
        }
        // この時点で未処理の桁は 8 ワード未満のはず

        // 未処理の桁が 4 ワード以上あるなら 4 ワード減算を行う。
        if (n & 0x4)
        {
            c = _SUBTRUCT_4WORDS_SBB(c, up, vp, wp);
            up += 4;
            vp += 4;
            wp += 4;
        }
        // この時点で未処理の桁は 4 ワード未満のはず

        // 未処理の桁が 2 ワード以上あるなら 2 ワード減算を行う。
        if (n & 0x2)
        {
            c = _SUBTRUCT_2WORDS_SBB(c, up, vp, wp);
            up += 2;
            vp += 2;
            wp += 2;
        }
        // この時点で未処理の桁は 2 ワード未満のはず

        // 未処理の桁が 1 ワード以上あるなら 1 ワード減算を行う。
        if (n & 1)
            c = _SUBTRUCT_UNIT(c, *up++, *vp++, wp++);
        return (c);
    }

    KaratsubaMultiplicationEngine::KaratsubaMultiplicationEngine(bool fixed, ClassicMultiplicationEngine& classic_engine)
        : _fixed(fixed), _classic_engine(classic_engine)
    {
    }

    KaratsubaMultiplicationEngine::~KaratsubaMultiplicationEngine()
    {
    }

    void KaratsubaMultiplicationEngine::Multiply_UX_UX(ThreadContext& tc, __UNIT_TYPE * u_buf, __UNIT_TYPE u_count, __UNIT_TYPE * v_buf, __UNIT_TYPE v_count, __UNIT_TYPE * w_buf)
    {
        ResourceHolderUINT root(tc);

        __UNIT_TYPE n = _MAXIMUM_UNIT(u_count, v_count);
        _UINT32_T log2_n;
        int lzcnt = _LZCNT_ALT_UNIT(n);
        int tzcnt = _TZCNT_ALT_UNIT(n);
        if (lzcnt + tzcnt == __UNIT_TYPE_BIT_COUNT - 1)
        {
            // n が 2 の累乗である場合

            log2_n = tzcnt;
        }
        else
        {
            // n が 2 の累乗ではない場合

            // n 以上でありかつ 2 の累乗である最小の値を、新たな n の値とする
            log2_n = (__UNIT_TYPE_BIT_COUNT - lzcnt);
            n = (__UNIT_TYPE)1 << log2_n;
        }

        if (u_count == n)
        {
            if (v_count == n)
            {
                if (n <= size_t_max / __UNIT_TYPE_BYTE_COUNT / 6 && ENABLED_KARATSUBA3)
                {
                    __UNIT_TYPE* temp_buf = root.AllocateBlock(6 * n * __UNIT_TYPE_BIT_COUNT);
                    __UNIT_TYPE* current_temp_buf_ptr = temp_buf;
                    Multiply_UX_UX_Karatsuba3(root, log2_n, temp_buf, current_temp_buf_ptr, u_buf, v_buf, w_buf);
                }
                else if (n <= size_t_max / 3 && ENABLED_KARATSUBA2)
                    Multiply_UX_UX_Karatsuba2(tc, log2_n, u_buf, v_buf, w_buf);
                else
                    Multiply_UX_UX_Karatsuba1(tc, log2_n, u_buf, v_buf, w_buf);
            }
            else
            {
                __UNIT_TYPE* new_v_buf;
                __UNIT_TYPE* new_w_buf;
                if (n <= size_t_max / __UNIT_TYPE_BYTE_COUNT / 9 && ENABLED_KARATSUBA3)
                {
                    __UNIT_TYPE* temp_buf = root.AllocateBlock(9 * n * __UNIT_TYPE_BIT_COUNT);
                    __UNIT_TYPE* current_temp_buf_ptr = temp_buf;
                    new_v_buf = current_temp_buf_ptr; current_temp_buf_ptr += n;
                    new_w_buf = current_temp_buf_ptr; current_temp_buf_ptr += n * 2;

                    _COPY_MEMORY_UNIT(new_v_buf, v_buf, v_count);
                    Multiply_UX_UX_Karatsuba3(root, log2_n, temp_buf, current_temp_buf_ptr, u_buf, new_v_buf, new_w_buf);
                    _COPY_MEMORY_UNIT(w_buf, new_w_buf, u_count + v_count);
                }
                else if (n <= size_t_max / 3 && ENABLED_KARATSUBA2)
                {
                    __UNIT_TYPE* temp_buf = root.AllocateBlock(n * 3 * __UNIT_TYPE_BIT_COUNT);
                    __UNIT_TYPE* current_temp_buf_ptr = nullptr;
                    new_v_buf = &temp_buf[0]; // n words
                    new_w_buf = &temp_buf[n];  // n * 2 words

                    _COPY_MEMORY_UNIT(new_v_buf, v_buf, v_count);
                    Multiply_UX_UX_Karatsuba2(tc, log2_n, u_buf, new_v_buf, new_w_buf);
                    _COPY_MEMORY_UNIT(w_buf, new_w_buf, u_count + v_count);
                }
                else
                {
                    __UNIT_TYPE* temp_buf = nullptr;
                    __UNIT_TYPE* current_temp_buf_ptr = nullptr;
                    new_v_buf = root.AllocateBlock(n * __UNIT_TYPE_BIT_COUNT);
                    new_w_buf = root.AllocateBlock(n * 2 * __UNIT_TYPE_BIT_COUNT);

                    _COPY_MEMORY_UNIT(new_v_buf, v_buf, v_count);
                    Multiply_UX_UX_Karatsuba1(tc, log2_n, u_buf, new_v_buf, new_w_buf);
                    _COPY_MEMORY_UNIT(w_buf, new_w_buf, u_count + v_count);
                }
            }
        }
        else
        {
            if (v_count == n)
            {
                __UNIT_TYPE* new_u_buf;
                __UNIT_TYPE* new_w_buf;
                if (n <= size_t_max / __UNIT_TYPE_BYTE_COUNT / 9 && ENABLED_KARATSUBA3)
                {
                    __UNIT_TYPE* temp_buf = root.AllocateBlock(9 * n * __UNIT_TYPE_BIT_COUNT);
                    __UNIT_TYPE* current_temp_buf_ptr = temp_buf;
                    new_u_buf = current_temp_buf_ptr; current_temp_buf_ptr += n;
                    new_w_buf = current_temp_buf_ptr; current_temp_buf_ptr += n * 2;

                    _COPY_MEMORY_UNIT(new_u_buf, u_buf, u_count);
                    Multiply_UX_UX_Karatsuba3(root, log2_n, temp_buf, current_temp_buf_ptr, new_u_buf, v_buf, new_w_buf);
                    _COPY_MEMORY_UNIT(w_buf, new_w_buf, u_count + v_count);
                }
                else if (n <= size_t_max / 3 && ENABLED_KARATSUBA2)
                {
                    __UNIT_TYPE* temp_buf = root.AllocateBlock(n * 3 * __UNIT_TYPE_BIT_COUNT);
                    __UNIT_TYPE* current_temp_buf_ptr = nullptr;
                    new_u_buf = &temp_buf[0]; // n words
                    new_w_buf = &temp_buf[n];  // n * 2 words

                    _COPY_MEMORY_UNIT(new_u_buf, u_buf, u_count);
                    Multiply_UX_UX_Karatsuba2(tc, log2_n, new_u_buf, v_buf, new_w_buf);
                    _COPY_MEMORY_UNIT(w_buf, new_w_buf, u_count + v_count);
                }
                else
                {
                    __UNIT_TYPE* temp_buf = nullptr;
                    __UNIT_TYPE* current_temp_buf_ptr = nullptr;
                    new_u_buf = root.AllocateBlock(n * __UNIT_TYPE_BIT_COUNT);
                    new_w_buf = root.AllocateBlock(n * 2 * __UNIT_TYPE_BIT_COUNT);

                    _COPY_MEMORY_UNIT(new_u_buf, u_buf, u_count);
                    Multiply_UX_UX_Karatsuba1(tc, log2_n, new_u_buf, v_buf, new_w_buf);
                    _COPY_MEMORY_UNIT(w_buf, new_w_buf, u_count + v_count);
                }
            }
            else
            {
                __UNIT_TYPE* new_u_buf;
                __UNIT_TYPE* new_v_buf;
                __UNIT_TYPE* new_w_buf;
                if (n <= size_t_max / __UNIT_TYPE_BYTE_COUNT / 10 && ENABLED_KARATSUBA3)
                {
                    __UNIT_TYPE* temp_buf = root.AllocateBlock(10 * n * __UNIT_TYPE_BIT_COUNT);
                    __UNIT_TYPE* current_temp_buf_ptr = temp_buf;
                    new_u_buf = current_temp_buf_ptr; current_temp_buf_ptr += n;
                    new_v_buf = current_temp_buf_ptr; current_temp_buf_ptr += n;
                    new_w_buf = current_temp_buf_ptr; current_temp_buf_ptr += n * 2;

                    _COPY_MEMORY_UNIT(new_u_buf, u_buf, u_count);
                    _COPY_MEMORY_UNIT(new_v_buf, v_buf, v_count);
                    Multiply_UX_UX_Karatsuba3(root, log2_n, temp_buf, current_temp_buf_ptr, new_u_buf, new_v_buf, new_w_buf);
                    _COPY_MEMORY_UNIT(w_buf, new_w_buf, u_count + v_count);
                }
                else if (n <= size_t_max / 4 && ENABLED_KARATSUBA2)
                {
                    __UNIT_TYPE* temp_buf = root.AllocateBlock(n * 4 * __UNIT_TYPE_BIT_COUNT);
                    __UNIT_TYPE* current_temp_buf_ptr = nullptr;
                    new_u_buf = &temp_buf[0]; // n words
                    new_v_buf = &temp_buf[n]; // n words
                    new_w_buf = &temp_buf[n + n];  // n * 2 words

                    _COPY_MEMORY_UNIT(new_u_buf, u_buf, u_count);
                    _COPY_MEMORY_UNIT(new_v_buf, v_buf, v_count);
                    Multiply_UX_UX_Karatsuba2(tc, log2_n, new_u_buf, new_v_buf, new_w_buf);
                    _COPY_MEMORY_UNIT(w_buf, new_w_buf, u_count + v_count);
                }
                else
                {
                    __UNIT_TYPE* temp_buf = nullptr;
                    __UNIT_TYPE* current_temp_buf_ptr = nullptr;
                    new_u_buf = root.AllocateBlock(n * __UNIT_TYPE_BIT_COUNT);
                    new_v_buf = root.AllocateBlock(n * __UNIT_TYPE_BIT_COUNT);
                    new_w_buf = root.AllocateBlock(n * 2 * __UNIT_TYPE_BIT_COUNT);

                    _COPY_MEMORY_UNIT(new_u_buf, u_buf, u_count);
                    _COPY_MEMORY_UNIT(new_v_buf, v_buf, v_count);
                    Multiply_UX_UX_Karatsuba1(tc, log2_n, new_u_buf, new_v_buf, new_w_buf);
                    _COPY_MEMORY_UNIT(w_buf, new_w_buf, u_count + v_count);
                }
            }
        }
    }

    void KaratsubaMultiplicationEngine::Multiply_UX_UX_Karatsuba1(ThreadContext& tc, _UINT32_T log2_n, __UNIT_TYPE * u_buf, __UNIT_TYPE * v_buf, __UNIT_TYPE * w_buf)
    {
        ResourceHolderUINT root(tc);

        __UNIT_TYPE n = (__UNIT_TYPE)1 << log2_n;
        if (!_fixed && log2_n < LOG2_N_THRESHOLD_CLASSIC)
        {
            // log2_n が閾値より小さい場合は classic 法で計算する

            _classic_engine.Multiply_UX_UX(u_buf, n, v_buf, n, w_buf);
        }
        else if (n <= size_t_max / 3 && ENABLED_KARATSUBA2)
        {
            // log2_n が閾値以下の場合

            Multiply_UX_UX_Karatsuba2(tc, log2_n, u_buf, v_buf, w_buf);
        }
        else
        {
            // log2_n が閾値より大きい場合

            _UINT32_T log2_n_half = log2_n - 1;
            __UNIT_TYPE n_half = (__UNIT_TYPE)1 << log2_n_half;

            __UNIT_TYPE* t1 = root.AllocateBlock(n_half * __UNIT_TYPE_BIT_COUNT);
            __UNIT_TYPE* t2 = root.AllocateBlock(n_half * __UNIT_TYPE_BIT_COUNT);
            __UNIT_TYPE* t3 = root.AllocateBlock(n * __UNIT_TYPE_BIT_COUNT);
            __UNIT_TYPE* t = root.AllocateBlock(n * __UNIT_TYPE_BIT_COUNT);

            Multiply_UX_UX_Karatsuba1(tc, log2_n_half, &u_buf[0], &v_buf[0], &w_buf[0]);
            Multiply_UX_UX_Karatsuba1(tc, log2_n_half, &u_buf[n_half], &v_buf[n_half], &w_buf[n]);

            SIGN_T t3_sign = SIGN_NEGATIVE;

            if (Compare_UX_UX(n_half, &u_buf[n_half], &u_buf[0]) >= 0)
            {
                Subtruct_UX_UX(n_half, &u_buf[n_half], &u_buf[0], t1);
#ifdef _DEBUG
                root.CheckBlock(t1);
#endif
            }
            else
            {
                t3_sign = INVERT_SIGN(t3_sign);
                Subtruct_UX_UX(n_half, &u_buf[0], &u_buf[n_half], t1);
#ifdef _DEBUG
                root.CheckBlock(t1);
#endif
            }

            if (Compare_UX_UX(n_half, &v_buf[n_half], &v_buf[0]) >= 0)
            {
                Subtruct_UX_UX(n_half, &v_buf[n_half], &v_buf[0], t2);
#ifdef _DEBUG
                root.CheckBlock(t2);
#endif
            }
            else
            {
                t3_sign = INVERT_SIGN(t3_sign);
                Subtruct_UX_UX(n_half, &v_buf[0], &v_buf[n_half], t2);
#ifdef _DEBUG
                root.CheckBlock(t2);
#endif
            }

            Multiply_UX_UX_Karatsuba1(tc, log2_n_half, t1, t2, t3);
#ifdef _DEBUG
            root.CheckBlock(t3);
#endif

            // 論理的な t の最大値のビット長は n * __UNIT_TYPE_BIT_COUNT * 2 + 1 で、
            // n ワードのバッファに格納しようとすると 1 ビット分不足するため、
            // 桁上りを t_carry として保存し、最後に t を加算した後の桁上り処理で t_carry も加算することにする。
            char t_carry = Add_UX_UX(n, &w_buf[n], &w_buf[0], t);
#ifdef _DEBUG
            root.CheckBlock(t);
#endif
            if (t3_sign >= 0)
            {
                t_carry += Add_UX_UX(n, t, t3, t);
#ifdef _DEBUG
                root.CheckBlock(t);
#endif
            }
            else
            {
                t_carry -= Subtruct_UX_UX(n, t, t3, t);
#ifdef _DEBUG
                root.CheckBlock(t);
#endif
            }

            if (t_carry < 0)
                throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_multiply_karatsuba.cpp;Multiply_UX_UX_Karatsuba;3");

            char carry = Add_UX_UX(n, &w_buf[n_half], t, &w_buf[n_half]);
            __UNIT_TYPE* w_ptr = &w_buf[n_half + n];
            __UNIT_TYPE count = n_half;

            // t に付随する t に収まり切れなかったビット (t_carry) も1回だけ加算する。
            while (count > 0 && (carry != 0 || t_carry != 0))
            {
                carry = _ADD_UNIT(carry, *w_ptr, t_carry, w_ptr);
                t_carry = 0;
                ++w_ptr;
            }
            if (carry != 0)
            {
                // 最上位桁まで carry が残ってしまった場合

                throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_multiply_karatsuba.cpp;Multiply_UX_UX_Karatsuba;4");
            }
        }
    }

    void KaratsubaMultiplicationEngine::Multiply_UX_UX_Karatsuba2(ThreadContext& tc, _UINT32_T log2_n, __UNIT_TYPE * u_buf, __UNIT_TYPE * v_buf, __UNIT_TYPE * w_buf)
    {
        ResourceHolderUINT root(tc);

        __UNIT_TYPE n = (__UNIT_TYPE)1 << log2_n;
        if (!_fixed && log2_n < LOG2_N_THRESHOLD_CLASSIC)
        {
            // log2_n が閾値より小さい場合は classic 法で計算する

            _classic_engine.Multiply_UX_UX(u_buf, n, v_buf, n, w_buf);
        }
        else if (n <= size_t_max / __UNIT_TYPE_BYTE_COUNT / 6 && ENABLED_KARATSUBA3)
        {
            // log2_n が閾値以下の場合

            __UNIT_TYPE* temp_buf = root.AllocateBlock(n * 6 * __UNIT_TYPE_BIT_COUNT);
            __UNIT_TYPE* current_temp_buf_ptr = temp_buf;
            Multiply_UX_UX_Karatsuba3(root, log2_n, temp_buf, current_temp_buf_ptr, u_buf, v_buf, w_buf);
        }
        else if (log2_n == 0)
        {
            // log2_n == 0 の場合

            w_buf[0] = _MULTIPLY_UNIT(*u_buf, *v_buf, &w_buf[1]);
#ifdef ENABLED_PERFORMANCE_COUNTER
            if (sizeof(w_buf[0]) == sizeof(_UINT32_T))
                IncrementMULTI32Counter();
            else
                IncrementMULTI64Counter();
#endif
        }
        else
        {
            // log2_n が閾値以上の場合

            _UINT32_T log2_n_half = log2_n - 1;
            __UNIT_TYPE n_half = (__UNIT_TYPE)1 << log2_n_half;

            __UNIT_TYPE* temp_buf;
            __UNIT_TYPE* t1;
            __UNIT_TYPE* t2;
            __UNIT_TYPE* t3;
            __UNIT_TYPE* t;
            temp_buf = root.AllocateBlock((n_half + n_half + n + n) * __UNIT_TYPE_BIT_COUNT);
            t1 = &temp_buf[0]; // n_half words
            t2 = &temp_buf[n_half]; // n_half words
            t3 = &temp_buf[n_half + n_half]; // n words
            t = &temp_buf[n_half + n_half + n]; // n words

            Multiply_UX_UX_Karatsuba2(tc, log2_n_half, &u_buf[0], &v_buf[0], &w_buf[0]);
            Multiply_UX_UX_Karatsuba2(tc, log2_n_half, &u_buf[n_half], &v_buf[n_half], &w_buf[n]);

            SIGN_T t3_sign = SIGN_NEGATIVE;

            if (Compare_UX_UX(n_half, &u_buf[n_half], &u_buf[0]) >= 0)
            {
                Subtruct_UX_UX(n_half, &u_buf[n_half], &u_buf[0], t1);
#ifdef _DEBUG
                root.CheckBlock(temp_buf);
#endif
            }
            else
            {
                t3_sign = INVERT_SIGN(t3_sign);
                Subtruct_UX_UX(n_half, &u_buf[0], &u_buf[n_half], t1);
#ifdef _DEBUG
                root.CheckBlock(temp_buf);
#endif
            }

            if (Compare_UX_UX(n_half, &v_buf[n_half], &v_buf[0]) >= 0)
            {
                Subtruct_UX_UX(n_half, &v_buf[n_half], &v_buf[0], t2);
#ifdef _DEBUG
                root.CheckBlock(temp_buf);
#endif
            }
            else
            {
                t3_sign = INVERT_SIGN(t3_sign);
                Subtruct_UX_UX(n_half, &v_buf[0], &v_buf[n_half], t2);
#ifdef _DEBUG
                root.CheckBlock(temp_buf);
#endif
            }

            Multiply_UX_UX_Karatsuba2(tc, log2_n_half, t1, t2, t3);
#ifdef _DEBUG
            root.CheckBlock(temp_buf);
#endif

            // 論理的な t の最大値のビット長は n * __UNIT_TYPE_BIT_COUNT * 2 + 1 で、
            // n ワードのバッファに格納しようとすると 1 ビット分不足するため、
            // 桁上りを t_carry として保存し、最後に t を加算した後の桁上り処理で t_carry も加算することにする。
            char t_carry = Add_UX_UX(n, &w_buf[n], &w_buf[0], t);
#ifdef _DEBUG
            root.CheckBlock(temp_buf);
#endif
            if (t3_sign >= 0)
            {
                t_carry += Add_UX_UX(n, t, t3, t);
#ifdef _DEBUG
                root.CheckBlock(temp_buf);
#endif
            }
            else
            {
                t_carry -= Subtruct_UX_UX(n, t, t3, t);
#ifdef _DEBUG
                root.CheckBlock(temp_buf);
#endif
            }

            if (t_carry < 0)
                throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_multiply_karatsuba.cpp;Multiply_UX_UX_Karatsuba;3");

            char carry = Add_UX_UX(n, &w_buf[n_half], t, &w_buf[n_half]);
            __UNIT_TYPE* w_ptr = &w_buf[n_half + n];
            __UNIT_TYPE count = n_half;

            // t に付随する t に収まり切れなかったビット (t_carry) も1回だけ加算する。
            while (count > 0 && (carry != 0 || t_carry != 0))
            {
                carry = _ADD_UNIT(carry, *w_ptr, t_carry, w_ptr);
                t_carry = 0;
                ++w_ptr;
            }
            if (carry != 0)
            {
                // 最上位桁まで carry が残ってしまった場合

                throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_multiply_karatsuba.cpp;Multiply_UX_UX_Karatsuba;4");
            }
            root.DeallocateBlock(temp_buf);
        }
    }

    void KaratsubaMultiplicationEngine::Multiply_UX_UX_Karatsuba3(ResourceHolderUINT & root, _UINT32_T log2_n, __UNIT_TYPE * temp_buf, __UNIT_TYPE * current_temp_buf_ptr, __UNIT_TYPE * u_buf, __UNIT_TYPE * v_buf, __UNIT_TYPE * w_buf)
    {
        if (!_fixed && log2_n < LOG2_N_THRESHOLD_CLASSIC)
        {
            // log2_n が閾値より小さい場合は classic 法で計算する

            __UNIT_TYPE n = (__UNIT_TYPE)1 << log2_n;
            _classic_engine.Multiply_UX_UX( u_buf, n, v_buf, n, w_buf);
        }
        else if (log2_n == 0)
        {
            // log2_n == 0 の場合

            w_buf[0] = _MULTIPLY_UNIT(*u_buf, *v_buf, &w_buf[1]);
#ifdef ENABLED_PERFORMANCE_COUNTER
            if (sizeof(w_buf[0]) == sizeof(_UINT32_T))
                IncrementMULTI32Counter();
            else
                IncrementMULTI64Counter();
#endif
        }
        else
        {
            // log2_n が閾値以上の場合

            __UNIT_TYPE n = (__UNIT_TYPE)1 << log2_n;
            _UINT32_T log2_n_half = log2_n - 1;
            __UNIT_TYPE n_half = (__UNIT_TYPE)1 << log2_n_half;

            __UNIT_TYPE* t1;
            __UNIT_TYPE* t2;
            __UNIT_TYPE* t3;
            __UNIT_TYPE* t;

            if (temp_buf == nullptr)
            {
                temp_buf = root.AllocateBlock(n * 6 * __UNIT_TYPE_BIT_COUNT);
                current_temp_buf_ptr = temp_buf;
            }
            t1 = current_temp_buf_ptr; current_temp_buf_ptr += n_half;
            //_ZERO_MEMORY_UNIT(t1, n_half);
            t2 = current_temp_buf_ptr; current_temp_buf_ptr += n_half;
            //_ZERO_MEMORY_UNIT(t2, n_half);
            t3 = current_temp_buf_ptr; current_temp_buf_ptr += n;
            //_ZERO_MEMORY_UNIT(t3, n);
            t = current_temp_buf_ptr; current_temp_buf_ptr += n;
            //_ZERO_MEMORY_UNIT(t, n);

            Multiply_UX_UX_Karatsuba3(root, log2_n_half, temp_buf, current_temp_buf_ptr, &u_buf[0], &v_buf[0], &w_buf[0]);
            Multiply_UX_UX_Karatsuba3(root, log2_n_half, temp_buf, current_temp_buf_ptr, &u_buf[n_half], &v_buf[n_half], &w_buf[n]);

            SIGN_T t3_sign = SIGN_NEGATIVE;

            if (Compare_UX_UX(n_half, &u_buf[n_half], &u_buf[0]) >= 0)
            {
                Subtruct_UX_UX(n_half, &u_buf[n_half], &u_buf[0], t1);
#ifdef _DEBUG
                root.CheckBlock(temp_buf);
#endif
            }
            else
            {
                t3_sign = INVERT_SIGN(t3_sign);
                Subtruct_UX_UX(n_half, &u_buf[0], &u_buf[n_half], t1);
#ifdef _DEBUG
                root.CheckBlock(temp_buf);
#endif
            }

            if (Compare_UX_UX(n_half, &v_buf[n_half], &v_buf[0]) >= 0)
            {
                Subtruct_UX_UX(n_half, &v_buf[n_half], &v_buf[0], t2);
#ifdef _DEBUG
                root.CheckBlock(temp_buf);
#endif
            }
            else
            {
                t3_sign = INVERT_SIGN(t3_sign);
                Subtruct_UX_UX(n_half, &v_buf[0], &v_buf[n_half], t2);
#ifdef _DEBUG
                root.CheckBlock(temp_buf);
#endif
            }

            Multiply_UX_UX_Karatsuba3(root, log2_n_half, temp_buf, current_temp_buf_ptr, t1, t2, t3);
#ifdef _DEBUG
            root.CheckBlock(temp_buf);
#endif

            // 論理的な t の最大値のビット長は n * __UNIT_TYPE_BIT_COUNT * 2 + 1 で、
            // n ワードのバッファに格納しようとすると 1 ビット分不足するため、
            // 桁上りを t_carry として保存し、最後に t を加算した後の桁上り処理で t_carry も加算することにする。
            char t_carry = Add_UX_UX(n, &w_buf[n], &w_buf[0], t);
#ifdef _DEBUG
            root.CheckBlock(temp_buf);
#endif
            if (t3_sign >= 0)
            {
                t_carry += Add_UX_UX(n, t, t3, t);
#ifdef _DEBUG
                root.CheckBlock(temp_buf);
#endif
            }
            else
            {
                t_carry -= Subtruct_UX_UX(n, t, t3, t);
#ifdef _DEBUG
                root.CheckBlock(temp_buf);
#endif
            }

            if (t_carry < 0)
                throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_multiply_karatsuba.cpp;Multiply_UX_UX_Karatsuba;3");

            char carry = Add_UX_UX(n, &w_buf[n_half], t, &w_buf[n_half]);
            __UNIT_TYPE* w_ptr = &w_buf[n_half + n];
            __UNIT_TYPE count = n_half;

            // t に付随する t に収まり切れなかったビット (t_carry) も1回だけ加算する。
            while (count > 0 && (carry != 0 || t_carry != 0))
            {
                carry = _ADD_UNIT(carry, *w_ptr, t_carry, w_ptr);
                t_carry = 0;
                ++w_ptr;
            }
            if (carry != 0)
            {
                // 最上位桁まで carry が残ってしまった場合

                throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_multiply_karatsuba.cpp;Multiply_UX_UX_Karatsuba;4");
            }
        }
    }



}


/*
 * END OF FILE
 */