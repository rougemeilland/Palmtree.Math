/*
 * The MIT License
 *
 * Copyright 2019 Palmtree Software.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */


#include "pmc_multiply_karatsuba.h"
#include "pmc_resourceholder_uint.h"
#include "pmc_exception.h"
#include "autogenerated_inline_func.h"

namespace Palmtree::Math::Core::Internal
{

    static SIGN_T Compare_UX_UX(__UNIT_TYPE count, __UNIT_TYPE* u, __UNIT_TYPE* v)
    {
        u += count;
        v += count;
        while (count > 0)
        {
            --u;
            --v;
            --count;

            if (*u > *v)
                return (SIGN_POSITIVE);
            else if (*u < *v)
                return (SIGN_NEGATIVE);
            else
            {
            }
        }
        return (SIGN_ZERO);
    }

    static char Add_UX_UX(__UNIT_TYPE n, __UNIT_TYPE* u_buf, __UNIT_TYPE* v_buf, __UNIT_TYPE* w_buf)
    {
        __UNIT_TYPE* up = u_buf;
        __UNIT_TYPE* vp = v_buf;
        __UNIT_TYPE* wp = w_buf;
        char c = 0;

        // まず 32 ワードずつ加算をする。
        __UNIT_TYPE count = n >> 5;
        while (count != 0)
        {
            c = _ADD_32WORDS_ADC(c, up, vp, wp);
            up += 32;
            vp += 32;
            wp += 32;
            --count;
        }
        // この時点で未処理の桁は 32 ワード未満のはず

        // 未処理の桁が 16 ワード以上あるなら 16 ワード加算を行う。
        if (n & 0x10)
        {
            c = _ADD_16WORDS_ADC(c, up, vp, wp);
            up += 16;
            vp += 16;
            wp += 16;
        }
        // この時点で未処理の桁は 16 ワード未満のはず

        // 未処理の桁が 8 ワード以上あるなら 8 ワード加算を行う。
        if (n & 0x8)
        {
            c = _ADD_8WORDS_ADC(c, up, vp, wp);
            up += 8;
            vp += 8;
            wp += 8;
        }
        // この時点で未処理の桁は 8 ワード未満のはず

        // 未処理の桁が 4 ワード以上あるなら 4 ワード加算を行う。
        if (n & 0x4)
        {
            c = _ADD_4WORDS_ADC(c, up, vp, wp);
            up += 4;
            vp += 4;
            wp += 4;
        }
        // この時点で未処理の桁は 4 ワード未満のはず

        // 未処理の桁が 2 ワード以上あるなら 2 ワード加算を行う。
        if (n & 0x2)
        {
            c = _ADD_2WORDS_ADC(c, up, vp, wp);
            up += 2;
            vp += 2;
            wp += 2;
        }
        // この時点で未処理の桁は 2 ワード未満のはず

        // 未処理の桁が 1 ワード以上あるなら 1 ワード加算を行う。
        if (n & 0x1)
            c = _ADD_UNIT(c, *up++, *vp++, wp++);

        return (c);
    }

    static char Subtruct_UX_UX(__UNIT_TYPE n, __UNIT_TYPE* up, __UNIT_TYPE* vp, __UNIT_TYPE* wp)
    {
        char c = 0;

        // まず 32 ワードずつ減算をする。
        __UNIT_TYPE count = n >> 5;
        while (count != 0)
        {
            c = _SUBTRUCT_32WORDS_SBB(c, up, vp, wp);
            up += 32;
            vp += 32;
            wp += 32;
            --count;
        }
        // この時点で未処理の桁は 32 ワード未満のはず

        // 未処理の桁が 16 ワード以上あるなら 16 ワード減算を行う。
        if (n & 0x10)
        {
            c = _SUBTRUCT_16WORDS_SBB(c, up, vp, wp);
            up += 16;
            vp += 16;
            wp += 16;
        }
        // この時点で未処理の桁は 16 ワード未満のはず

        // 未処理の桁が 8 ワード以上あるなら 8 ワード減算を行う。
        if (n & 0x8)
        {
            c = _SUBTRUCT_8WORDS_SBB(c, up, vp, wp);
            up += 8;
            vp += 8;
            wp += 8;
        }
        // この時点で未処理の桁は 8 ワード未満のはず

        // 未処理の桁が 4 ワード以上あるなら 4 ワード減算を行う。
        if (n & 0x4)
        {
            c = _SUBTRUCT_4WORDS_SBB(c, up, vp, wp);
            up += 4;
            vp += 4;
            wp += 4;
        }
        // この時点で未処理の桁は 4 ワード未満のはず

        // 未処理の桁が 2 ワード以上あるなら 2 ワード減算を行う。
        if (n & 0x2)
        {
            c = _SUBTRUCT_2WORDS_SBB(c, up, vp, wp);
            up += 2;
            vp += 2;
            wp += 2;
        }
        // この時点で未処理の桁は 2 ワード未満のはず

        // 未処理の桁が 1 ワード以上あるなら 1 ワード減算を行う。
        if (n & 1)
            c = _SUBTRUCT_UNIT(c, *up++, *vp++, wp++);
        return (c);
    }

    void Multiply_UX_UX_Karatsuba(ThreadContext& tc, __UNIT_TYPE n, __UNIT_TYPE * u_buf, __UNIT_TYPE * v_buf, __UNIT_TYPE * w_buf)
    {
        if (n == 0)
        {
            // n == 0 の場合

            throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_multiply_karatsuba.cpp;Multiply_UX_UX_Karatsuba;1");
        }
        else if (n == 1)
        {
            // n == 1 の場合

            w_buf[0] = _MULTIPLY_UNIT(*u_buf, *v_buf, &w_buf[1]);
        }
        else
        {
            // n > 1 の場合

            ResourceHolderUINT root(tc);
#ifdef _DEBUG
            int lzcnt = _LZCNT_ALT_UNIT(n);
            int tzcnt = _TZCNT_ALT_UNIT(n);
            if (lzcnt + tzcnt != __UNIT_TYPE_BIT_COUNT - 1)
                throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_multiply_karatsuba.cpp;Multiply_UX_UX_Karatsuba;2");
#endif
            __UNIT_TYPE n_half = n >> 1;
            Multiply_UX_UX_Karatsuba(tc, n_half, &u_buf[0], &v_buf[0], &w_buf[0]);
            Multiply_UX_UX_Karatsuba(tc, n_half, &u_buf[n_half], &v_buf[n_half], &w_buf[n]);
            SIGN_T t3_sign = SIGN_NEGATIVE;

            __UNIT_TYPE* t1 = root.AllocateBlock(n_half * __UNIT_TYPE_BIT_COUNT);
            if (Compare_UX_UX(n_half, &u_buf[n_half], &u_buf[0]) >= 0)
            {
                Subtruct_UX_UX(n_half, &u_buf[n_half], &u_buf[0], t1);
#ifdef _DEBUG
                root.CheckBlock(t1);
#endif
            }
            else
            {
                t3_sign = INVERT_SIGN(t3_sign);
                Subtruct_UX_UX(n_half, &u_buf[0], &u_buf[n_half], t1);
#ifdef _DEBUG
                root.CheckBlock(t1);
#endif
            }

            __UNIT_TYPE* t2 = root.AllocateBlock(n_half * __UNIT_TYPE_BIT_COUNT);
            if (Compare_UX_UX(n_half, &v_buf[n_half], &v_buf[0]) >= 0)
            {
                Subtruct_UX_UX(n_half, &v_buf[n_half], &v_buf[0], t2);
#ifdef _DEBUG
                root.CheckBlock(t2);
#endif
            }
            else
            {
                t3_sign = INVERT_SIGN(t3_sign);
                Subtruct_UX_UX(n_half, &v_buf[0], &v_buf[n_half], t2);
#ifdef _DEBUG
                root.CheckBlock(t2);
#endif
            }

            __UNIT_TYPE* t3 = root.AllocateBlock(n * __UNIT_TYPE_BIT_COUNT);
            Multiply_UX_UX_Karatsuba(tc, n_half, t1, t2, t3);
#ifdef _DEBUG
            root.CheckBlock(t3);
#endif

            __UNIT_TYPE* t = root.AllocateBlock(n * __UNIT_TYPE_BIT_COUNT);
            Add_UX_UX(n, &w_buf[n], &w_buf[0], t);
#ifdef _DEBUG
            root.CheckBlock(t);
#endif
            if (t3_sign >= 0)
            {
                Add_UX_UX(n, t, t3, t);
#ifdef _DEBUG
                root.CheckBlock(t);
#endif
            }
            else
            {
                Subtruct_UX_UX(n, t, t3, t);
#ifdef _DEBUG
                root.CheckBlock(t);
#endif
            }

            char carry = Add_UX_UX(n, &w_buf[n_half], t, &w_buf[n_half]);
            __UNIT_TYPE* w_ptr = &w_buf[n_half + n];
            __UNIT_TYPE count = n_half;
            while (count > 0 && carry != 0)
            {
                carry = _ADD_UNIT(carry, *w_ptr, 0, w_ptr);
                ++w_ptr;
            }
            if (carry != 0)
            {
                // 最上位桁まで carry が残ってしまった場合

                throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_multiply_karatsuba.cpp;Multiply_UX_UX_Karatsuba;3");
            }
        }
    }

    KaratsubaMultiplicationEngine::KaratsubaMultiplicationEngine()
    {
    }

    KaratsubaMultiplicationEngine::~KaratsubaMultiplicationEngine()
    {
    }

    void KaratsubaMultiplicationEngine::Multiply_UX_UX(ThreadContext& tc, __UNIT_TYPE * u_buf, __UNIT_TYPE u_count, __UNIT_TYPE * v_buf, __UNIT_TYPE v_count, __UNIT_TYPE * w_buf)
    {
        ResourceHolderUINT root(tc);
        __UNIT_TYPE n = _MAXIMUM_UNIT(u_count, v_count);
        int lzcnt = _LZCNT_ALT_UNIT(n);
        int tzcnt = _TZCNT_ALT_UNIT(n);
        if (lzcnt + tzcnt == __UNIT_TYPE_BIT_COUNT - 1)
        {
            // n が 2 の累乗である場合

            // nop
        }
        else
        {
            // n が 2 の累乗ではない場合

            // n 以上であり、かつ 2 の累乗である、最小の値を求める
            n = (__UNIT_TYPE)1 << (__UNIT_TYPE_BIT_COUNT - lzcnt);
        }
        if (u_count == n)
        {
            if (v_count == n)
                Multiply_UX_UX_Karatsuba(tc, n, u_buf, v_buf, w_buf);
            else
            {
                __UNIT_TYPE* new_v_buf = root.AllocateBlock(n * __UNIT_TYPE_BIT_COUNT);
                _COPY_MEMORY_UNIT(new_v_buf, v_buf, v_count);
                __UNIT_TYPE* new_w_buf = root.AllocateBlock(n * 2 * __UNIT_TYPE_BIT_COUNT);
                Multiply_UX_UX_Karatsuba(tc, n, u_buf, new_v_buf, new_w_buf);
                _COPY_MEMORY_UNIT(w_buf, new_w_buf, n + v_count);
            }
        }
        else
        {
            if (v_count == n)
            {
                __UNIT_TYPE* new_u_buf = root.AllocateBlock(n * __UNIT_TYPE_BIT_COUNT);
                _COPY_MEMORY_UNIT(new_u_buf, u_buf, u_count);
                __UNIT_TYPE* new_w_buf = root.AllocateBlock(n * 2 * __UNIT_TYPE_BIT_COUNT);
                Multiply_UX_UX_Karatsuba(tc, n, new_u_buf, v_buf, new_w_buf);
                _COPY_MEMORY_UNIT(w_buf, new_w_buf, u_count + n);
            }
            else
            {
                __UNIT_TYPE* new_u_buf = root.AllocateBlock(n * __UNIT_TYPE_BIT_COUNT);
                _COPY_MEMORY_UNIT(new_u_buf, u_buf, u_count);
                __UNIT_TYPE* new_v_buf = root.AllocateBlock(n * __UNIT_TYPE_BIT_COUNT);
                _COPY_MEMORY_UNIT(new_v_buf, v_buf, v_count);
                __UNIT_TYPE* new_w_buf = root.AllocateBlock(n * 2 * __UNIT_TYPE_BIT_COUNT);
                Multiply_UX_UX_Karatsuba(tc, n, new_u_buf, new_v_buf, new_w_buf);
                _COPY_MEMORY_UNIT(w_buf, new_w_buf, u_count + v_count);
            }
        }
    }

}


/*
 * END OF FILE
 */