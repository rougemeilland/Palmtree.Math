/*
 * The MIT License
 *
 * Copyright 2019 Palmtree Software.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */


#include <chrono>
#include "pmc_bidirectionallistheader.h"
#include "pmc_multiply_karatsuba.h"
#include "pmc_uint_internal.h"
#include "pmc_exception.h"
#include "pmc_lock.h"
#include "autogenerated_inline_func.h"

namespace Palmtree::Math::Core::Internal
{

#define MAGIC_DATA ((__UNIT_TYPE)0x3333333333333333)

    static SIGN_T Compare_UX_UX(__UNIT_TYPE count, __UNIT_TYPE* u, __UNIT_TYPE* v)
    {
        u += count;
        v += count;
        while (count > 0)
        {
            --u;
            --v;
            --count;

            if (*u > *v)
                return (SIGN_POSITIVE);
            else if (*u < *v)
                return (SIGN_NEGATIVE);
            else
            {
            }
        }
        return (SIGN_ZERO);
    }

    static char Add_UX_UX(__UNIT_TYPE n, __UNIT_TYPE* u_buf, __UNIT_TYPE* v_buf, __UNIT_TYPE* w_buf)
    {
        __UNIT_TYPE* up = u_buf;
        __UNIT_TYPE* vp = v_buf;
        __UNIT_TYPE* wp = w_buf;
        char c = 0;

        // まず 32 ワードずつ加算をする。
        __UNIT_TYPE count = n >> 5;
        while (count != 0)
        {
            c = _ADD_32WORDS_ADC(c, up, vp, wp);
            up += 32;
            vp += 32;
            wp += 32;
            --count;
        }
        // この時点で未処理の桁は 32 ワード未満のはず

        // 未処理の桁が 16 ワード以上あるなら 16 ワード加算を行う。
        if (n & 0x10)
        {
            c = _ADD_16WORDS_ADC(c, up, vp, wp);
            up += 16;
            vp += 16;
            wp += 16;
        }
        // この時点で未処理の桁は 16 ワード未満のはず

        // 未処理の桁が 8 ワード以上あるなら 8 ワード加算を行う。
        if (n & 0x8)
        {
            c = _ADD_8WORDS_ADC(c, up, vp, wp);
            up += 8;
            vp += 8;
            wp += 8;
        }
        // この時点で未処理の桁は 8 ワード未満のはず

        // 未処理の桁が 4 ワード以上あるなら 4 ワード加算を行う。
        if (n & 0x4)
        {
            c = _ADD_4WORDS_ADC(c, up, vp, wp);
            up += 4;
            vp += 4;
            wp += 4;
        }
        // この時点で未処理の桁は 4 ワード未満のはず

        // 未処理の桁が 2 ワード以上あるなら 2 ワード加算を行う。
        if (n & 0x2)
        {
            c = _ADD_2WORDS_ADC(c, up, vp, wp);
            up += 2;
            vp += 2;
            wp += 2;
        }
        // この時点で未処理の桁は 2 ワード未満のはず

        // 未処理の桁が 1 ワード以上あるなら 1 ワード加算を行う。
        if (n & 0x1)
            c = _ADD_UNIT(c, *up++, *vp++, wp++);

        return (c);
    }

    static char Subtruct_UX_UX(__UNIT_TYPE n, __UNIT_TYPE* up, __UNIT_TYPE* vp, __UNIT_TYPE* wp)
    {
        char c = 0;

        // まず 32 ワードずつ減算をする。
        __UNIT_TYPE count = n >> 5;
        while (count != 0)
        {
            c = _SUBTRUCT_32WORDS_SBB(c, up, vp, wp);
            up += 32;
            vp += 32;
            wp += 32;
            --count;
        }
        // この時点で未処理の桁は 32 ワード未満のはず

        // 未処理の桁が 16 ワード以上あるなら 16 ワード減算を行う。
        if (n & 0x10)
        {
            c = _SUBTRUCT_16WORDS_SBB(c, up, vp, wp);
            up += 16;
            vp += 16;
            wp += 16;
        }
        // この時点で未処理の桁は 16 ワード未満のはず

        // 未処理の桁が 8 ワード以上あるなら 8 ワード減算を行う。
        if (n & 0x8)
        {
            c = _SUBTRUCT_8WORDS_SBB(c, up, vp, wp);
            up += 8;
            vp += 8;
            wp += 8;
        }
        // この時点で未処理の桁は 8 ワード未満のはず

        // 未処理の桁が 4 ワード以上あるなら 4 ワード減算を行う。
        if (n & 0x4)
        {
            c = _SUBTRUCT_4WORDS_SBB(c, up, vp, wp);
            up += 4;
            vp += 4;
            wp += 4;
        }
        // この時点で未処理の桁は 4 ワード未満のはず

        // 未処理の桁が 2 ワード以上あるなら 2 ワード減算を行う。
        if (n & 0x2)
        {
            c = _SUBTRUCT_2WORDS_SBB(c, up, vp, wp);
            up += 2;
            vp += 2;
            wp += 2;
        }
        // この時点で未処理の桁は 2 ワード未満のはず

        // 未処理の桁が 1 ワード以上あるなら 1 ワード減算を行う。
        if (n & 1)
            c = _SUBTRUCT_UNIT(c, *up++, *vp++, wp++);
        return (c);
    }

    int KaratsubaMultiplicationEngine::_life_time_seconds = 1;
    int KaratsubaMultiplicationEngine::_interval_time_seconds = 1;

    KaratsubaMultiplicationEngine::SmartPointer::SmartPointer(MemoryManager & mm, WordArray * raw_ptr)
        : _mm(mm), _raw_ptr(raw_ptr), _owner(true)
    {
    }

    KaratsubaMultiplicationEngine::SmartPointer::SmartPointer(SmartPointer & p)
        : _mm(p._mm), _raw_ptr(p._raw_ptr), _owner(true)
    {
        p._owner = false;
    }

    KaratsubaMultiplicationEngine::SmartPointer::~SmartPointer()
    {
        if (_owner)
            _mm.Deallocate(_raw_ptr);
    }

    __UNIT_TYPE * KaratsubaMultiplicationEngine::SmartPointer::Array() const
    {
        return (_raw_ptr->Array());
    }

#ifdef _DEBUG
    void KaratsubaMultiplicationEngine::SmartPointer::Check()
    {
        _raw_ptr->Check();
    }
#endif

    KaratsubaMultiplicationEngine::LinkElement::LinkElement()
        : BidirectionalListHeader<LinkElement>(this)
    {
    }

    KaratsubaMultiplicationEngine::LinkElement::~LinkElement()
    {
    }

    KaratsubaMultiplicationEngine::WordArray * KaratsubaMultiplicationEngine::LinkElement::ToWordArray()
    {
        throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_multiply_karatsuba.cpp;KaratsubaMultiplicationEngine::MemoryManager::LinkElement::WordArray;1");
    }

    KaratsubaMultiplicationEngine::WordArray::WordArray(int log2_n)
    {
        if (log2_n < 0 || log2_n >= __UNIT_TYPE_BIT_COUNT)
            throw ArgumentOutOfRangeException(L"n の値が指定可能な範囲を超えています。");
        _log2_n = log2_n;
#ifdef _DEBUG
        _payload_count = ((__UNIT_TYPE)1 << log2_n) + 2;
#else
        _payload_count = (__UNIT_TYPE)1 << log2_n;
#endif
        _payload = new __UNIT_TYPE[_payload_count];
        _destructed = std::chrono::steady_clock::now() + std::chrono::seconds(_life_time_seconds);
    }

    KaratsubaMultiplicationEngine::WordArray::~WordArray()
    {
        delete _payload;
    }

    KaratsubaMultiplicationEngine::WordArray * KaratsubaMultiplicationEngine::WordArray::ToWordArray()
    {
        return (this);
    }

    int KaratsubaMultiplicationEngine::WordArray::n() const
    {
        return (_log2_n);
    }

    void KaratsubaMultiplicationEngine::WordArray::Clear()
    {
        _ZERO_MEMORY_UNIT(_payload, _payload_count);
#ifdef _DEBUG
        _payload[0] = MAGIC_DATA;
        _payload[_payload_count - 1] = MAGIC_DATA;
#endif
    }

    __UNIT_TYPE * KaratsubaMultiplicationEngine::WordArray::Array() const
    {
#ifdef _DEBUG
        return (_payload + 1);
#else
        return (_payload);
#endif
    }

    std::chrono::steady_clock::time_point KaratsubaMultiplicationEngine::WordArray::Destructed() const
    {
        return (_destructed);
    }

    void KaratsubaMultiplicationEngine::WordArray::UpdateDestructed()
    {
        _destructed = std::chrono::steady_clock::now() + std::chrono::seconds(_life_time_seconds);
    }

#ifdef _DEBUG
    void KaratsubaMultiplicationEngine::WordArray::Check()
    {
        if (_payload[0] != MAGIC_DATA)
            throw BadBufferException(L"メモリ領域の不整合を検出しました。", L"pmc_multiply_karatsuba.cpp;KaratsubaMultiplicationEngine::WordArray::Check;1");
        if (_payload[_payload_count - 1] != MAGIC_DATA)
            throw BadBufferException(L"メモリ領域の不整合を検出しました。", L"pmc_multiply_karatsuba.cpp;KaratsubaMultiplicationEngine::WordArray::Check;2");
    }
#endif

    KaratsubaMultiplicationEngine::LinkRoot::LinkRoot()
    {
        _next_cleaned = std::chrono::steady_clock::now() + std::chrono::seconds(_interval_time_seconds);
    }

    KaratsubaMultiplicationEngine::LinkRoot::~LinkRoot()
    {
    }

    void KaratsubaMultiplicationEngine::LinkRoot::Add(LinkElement * p)
    {
        BidirectionalListHeader::AddAffter(p);
    }

    KaratsubaMultiplicationEngine::WordArray * KaratsubaMultiplicationEngine::LinkRoot::GetNewElement(int log2_n)
    {
        std::chrono::steady_clock::time_point now = std::chrono::steady_clock::now();
        if (now >= _next_cleaned)
        {
            RemoveOldElements(now);
            _next_cleaned = now + std::chrono::seconds(_interval_time_seconds);
        }
        WordArray* p;
        if (Next() == this)
            p = new WordArray(log2_n);
        else
        {
            p = Prev()->ToWordArray();
            p->Remove();
        }
        p->Clear();
        return (p);
    }

    void KaratsubaMultiplicationEngine::LinkRoot::RemoveOldElements(std::chrono::steady_clock::time_point boundary)
    {
        while (Prev() != this)
        {
            WordArray* p = Prev()->ToWordArray();
            if (p->Destructed() >= boundary)
                break;
            p->Remove();
            delete p;
        }
    }

    void KaratsubaMultiplicationEngine::LinkRoot::RemoveAllElements()
    {
        while (Prev() != this)
        {
            WordArray* p = Prev()->ToWordArray();
            p->Remove();
            delete p;
        }
    }

    KaratsubaMultiplicationEngine::MemoryManager::MemoryManager()
    {
    }

    KaratsubaMultiplicationEngine::MemoryManager::~MemoryManager()
    {
        for (int index = 0; index < __UNIT_TYPE_BIT_COUNT; ++index)
            _root[index].RemoveAllElements();
    }

    KaratsubaMultiplicationEngine::SmartPointer KaratsubaMultiplicationEngine::MemoryManager::Allocate(int log2_n)
    {
        Lock lock_obj;
        if (log2_n < 0 || log2_n >= __UNIT_TYPE_BIT_COUNT)
            throw ArgumentOutOfRangeException(L"n の値が指定可能な範囲を超えています。");
        WordArray* p = _root[log2_n].GetNewElement(log2_n);
        return (SmartPointer(*this, p));
    }

    void KaratsubaMultiplicationEngine::MemoryManager::Deallocate(WordArray * buffer)
    {
        Lock lock_obj;
        buffer->UpdateDestructed();
        _root[buffer->n()].Add(buffer);
    }

    KaratsubaMultiplicationEngine::KaratsubaMultiplicationEngine()
    {
    }

    KaratsubaMultiplicationEngine::~KaratsubaMultiplicationEngine()
    {
    }

    void KaratsubaMultiplicationEngine::Multiply_UX_UX(ThreadContext& tc, __UNIT_TYPE * u_buf, __UNIT_TYPE u_count, __UNIT_TYPE * v_buf, __UNIT_TYPE v_count, __UNIT_TYPE * w_buf)
    {
        __UNIT_TYPE n = _MAXIMUM_UNIT(u_count, v_count);
        int lzcnt = _LZCNT_ALT_UNIT(n);
        int log2_n = __UNIT_TYPE_BIT_COUNT - lzcnt;
        n = (__UNIT_TYPE)1 << log2_n;

        if (u_count == n)
        {
            if (v_count == n)
                Multiply_UX_UX_Karatsuba(tc, log2_n, u_buf, v_buf, w_buf);
            else
            {
                SmartPointer new_v_buf = _mm.Allocate(log2_n);
                _COPY_MEMORY_UNIT(new_v_buf.Array(), v_buf, v_count);
#ifdef _DEBUG
                new_v_buf.Check();
#endif
                SmartPointer new_w_buf = _mm.Allocate(log2_n + 1);
                Multiply_UX_UX_Karatsuba(tc, log2_n, u_buf, new_v_buf.Array(), new_w_buf.Array());
                _COPY_MEMORY_UNIT(w_buf, new_w_buf.Array(), n + v_count);
#ifdef _DEBUG
                new_w_buf.Check();
#endif
            }
        }
        else
        {
            if (v_count == n)
            {
                SmartPointer new_u_buf = _mm.Allocate(log2_n);
                _COPY_MEMORY_UNIT(new_u_buf.Array(), u_buf, u_count);
#ifdef _DEBUG
                new_u_buf.Check();
#endif
                SmartPointer new_w_buf = _mm.Allocate(log2_n + 1);
                Multiply_UX_UX_Karatsuba(tc, log2_n, new_u_buf.Array(), v_buf, new_w_buf.Array());
                _COPY_MEMORY_UNIT(w_buf, new_w_buf.Array(), u_count + n);
#ifdef _DEBUG
                new_w_buf.Check();
#endif
            }
            else
            {
                SmartPointer new_u_buf = _mm.Allocate(log2_n);
                _COPY_MEMORY_UNIT(new_u_buf.Array(), u_buf, u_count);
#ifdef _DEBUG
                new_u_buf.Check();
#endif
                SmartPointer new_v_buf = _mm.Allocate(log2_n);
                _COPY_MEMORY_UNIT(new_v_buf.Array(), v_buf, v_count);
#ifdef _DEBUG
                new_v_buf.Check();
#endif
                SmartPointer new_w_buf = _mm.Allocate(log2_n + 1);
                Multiply_UX_UX_Karatsuba(tc, log2_n, new_u_buf.Array(), new_v_buf.Array(), new_w_buf.Array());
                _COPY_MEMORY_UNIT(w_buf, new_w_buf.Array(), u_count + v_count);
#ifdef _DEBUG
                new_w_buf.Check();
#endif
            }
        }
    }

    void KaratsubaMultiplicationEngine::Multiply_UX_UX_Karatsuba(ThreadContext & tc, int log2_n, __UNIT_TYPE * u_buf, __UNIT_TYPE * v_buf, __UNIT_TYPE * w_buf)
    {
        if (log2_n == 0)
        {
            // log2_n == 0 の場合

            w_buf[0] = _MULTIPLY_UNIT(*u_buf, *v_buf, &w_buf[1]);
#ifdef ENABLED_PERFORMANCE_COUNTER
            if (sizeof(w_buf[0]) == sizeof(_UINT32_T))
                IncrementMULTI32Counter();
            else
                IncrementMULTI64Counter();
#endif
        }
        else
        {
            // log2_n > 0 の場合

            __UNIT_TYPE n = (__UNIT_TYPE)1 << log2_n;
            __UNIT_TYPE n_half = n >> 1;
            Multiply_UX_UX_Karatsuba(tc, log2_n - 1, &u_buf[0], &v_buf[0], &w_buf[0]);
            Multiply_UX_UX_Karatsuba(tc, log2_n - 1, &u_buf[n_half], &v_buf[n_half], &w_buf[n]);

            SIGN_T t3_sign = SIGN_NEGATIVE;

            SmartPointer t1 = _mm.Allocate(log2_n - 1);
            if (Compare_UX_UX(n_half, &u_buf[n_half], &u_buf[0]) >= 0)
            {
                Subtruct_UX_UX(n_half, &u_buf[n_half], &u_buf[0], t1.Array());
#ifdef _DEBUG
                t1.Check();
#endif
            }
            else
            {
                t3_sign = INVERT_SIGN(t3_sign);
                Subtruct_UX_UX(n_half, &u_buf[0], &u_buf[n_half], t1.Array());
#ifdef _DEBUG
                t1.Check();
#endif
            }

            SmartPointer t2 = _mm.Allocate(log2_n - 1);
            if (Compare_UX_UX(n_half, &v_buf[n_half], &v_buf[0]) >= 0)
            {
                Subtruct_UX_UX(n_half, &v_buf[n_half], &v_buf[0], t2.Array());
#ifdef _DEBUG
                t2.Check();
#endif
            }
            else
            {
                t3_sign = INVERT_SIGN(t3_sign);
                Subtruct_UX_UX(n_half, &v_buf[0], &v_buf[n_half], t2.Array());
#ifdef _DEBUG
                t2.Check();
#endif
            }

            SmartPointer t3 = _mm.Allocate(log2_n);
            Multiply_UX_UX_Karatsuba(tc, log2_n - 1, t1.Array(), t2.Array(), t3.Array());
#ifdef _DEBUG
            t3.Check();
#endif

            SmartPointer t = _mm.Allocate(log2_n);

            // 論理的な t の最大値のビット長は n * __UNIT_TYPE_BIT_COUNT * 2 + 1 で、
            // n ワードのバッファに格納しようとすると 1 ビット分不足するため、
            // 桁上りを t_carry として保存し、最後に t を加算した後の桁上り処理で t_carry も加算することにする。
            char t_carry = Add_UX_UX(n, &w_buf[n], &w_buf[0], t.Array());
#ifdef _DEBUG
            t.Check();
#endif
            if (t3_sign >= 0)
            {
                t_carry += Add_UX_UX(n, t.Array(), t3.Array(), t.Array());
#ifdef _DEBUG
                t.Check();
#endif
            }
            else
            {
                t_carry -= Subtruct_UX_UX(n, t.Array(), t3.Array(), t.Array());
#ifdef _DEBUG
                t.Check();
#endif
            }

            if (t_carry < 0)
                throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_multiply_karatsuba.cpp;Multiply_UX_UX_Karatsuba;3");

            char carry = Add_UX_UX(n, &w_buf[n_half], t.Array(), &w_buf[n_half]);
            __UNIT_TYPE* w_ptr = &w_buf[n_half + n];
            __UNIT_TYPE count = n_half;

            // t に付随する t に収まり切れなかったビット (t_carry) も1回だけ加算する。
            while (count > 0 && (carry != 0 || t_carry != 0))
            {
                carry = _ADD_UNIT(carry, *w_ptr, t_carry, w_ptr);
                t_carry = 0;
                ++w_ptr;
                --count;
            }
            if (carry != 0)
            {
                // 最上位桁まで carry が残ってしまった場合

                throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_multiply_karatsuba.cpp;Multiply_UX_UX_Karatsuba;4");
            }
        }
    }

}


/*
 * END OF FILE
 */