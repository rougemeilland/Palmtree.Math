/*
 * The MIT License
 *
 * Copyright 2019 Palmtree Software.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */


#include "pmc_multiply_karatsuba.h"
#include "pmc_multiply_classic.h"
#include "pmc_resourceholder_uint.h"
#include "pmc_exception.h"
#include "autogenerated_inline_func.h"

#define LOG2_N_THRESHOLD_CLASSIC    (20) // log2_n がこの値未満ならば classic法 に切り替える
#define LOG2_N_THRESHOLD_COMPOSITE  (27) // log2_n がこの値以下ならば複数の一時メモリ獲得を1回にまとめる

namespace Palmtree::Math::Core::Internal
{

    static SIGN_T Compare_UX_UX(__UNIT_TYPE count, __UNIT_TYPE* u, __UNIT_TYPE* v)
    {
        u += count;
        v += count;
        while (count > 0)
        {
            --u;
            --v;
            --count;

            if (*u > *v)
                return (SIGN_POSITIVE);
            else if (*u < *v)
                return (SIGN_NEGATIVE);
            else
            {
            }
        }
        return (SIGN_ZERO);
    }

    static char Add_UX_UX(__UNIT_TYPE n, __UNIT_TYPE* u_buf, __UNIT_TYPE* v_buf, __UNIT_TYPE* w_buf)
    {
        __UNIT_TYPE* up = u_buf;
        __UNIT_TYPE* vp = v_buf;
        __UNIT_TYPE* wp = w_buf;
        char c = 0;

        // まず 32 ワードずつ加算をする。
        __UNIT_TYPE count = n >> 5;
        while (count != 0)
        {
            c = _ADD_32WORDS_ADC(c, up, vp, wp);
            up += 32;
            vp += 32;
            wp += 32;
            --count;
        }
        // この時点で未処理の桁は 32 ワード未満のはず

        // 未処理の桁が 16 ワード以上あるなら 16 ワード加算を行う。
        if (n & 0x10)
        {
            c = _ADD_16WORDS_ADC(c, up, vp, wp);
            up += 16;
            vp += 16;
            wp += 16;
        }
        // この時点で未処理の桁は 16 ワード未満のはず

        // 未処理の桁が 8 ワード以上あるなら 8 ワード加算を行う。
        if (n & 0x8)
        {
            c = _ADD_8WORDS_ADC(c, up, vp, wp);
            up += 8;
            vp += 8;
            wp += 8;
        }
        // この時点で未処理の桁は 8 ワード未満のはず

        // 未処理の桁が 4 ワード以上あるなら 4 ワード加算を行う。
        if (n & 0x4)
        {
            c = _ADD_4WORDS_ADC(c, up, vp, wp);
            up += 4;
            vp += 4;
            wp += 4;
        }
        // この時点で未処理の桁は 4 ワード未満のはず

        // 未処理の桁が 2 ワード以上あるなら 2 ワード加算を行う。
        if (n & 0x2)
        {
            c = _ADD_2WORDS_ADC(c, up, vp, wp);
            up += 2;
            vp += 2;
            wp += 2;
        }
        // この時点で未処理の桁は 2 ワード未満のはず

        // 未処理の桁が 1 ワード以上あるなら 1 ワード加算を行う。
        if (n & 0x1)
            c = _ADD_UNIT(c, *up++, *vp++, wp++);

        return (c);
    }

    static char Subtruct_UX_UX(__UNIT_TYPE n, __UNIT_TYPE* up, __UNIT_TYPE* vp, __UNIT_TYPE* wp)
    {
        char c = 0;

        // まず 32 ワードずつ減算をする。
        __UNIT_TYPE count = n >> 5;
        while (count != 0)
        {
            c = _SUBTRUCT_32WORDS_SBB(c, up, vp, wp);
            up += 32;
            vp += 32;
            wp += 32;
            --count;
        }
        // この時点で未処理の桁は 32 ワード未満のはず

        // 未処理の桁が 16 ワード以上あるなら 16 ワード減算を行う。
        if (n & 0x10)
        {
            c = _SUBTRUCT_16WORDS_SBB(c, up, vp, wp);
            up += 16;
            vp += 16;
            wp += 16;
        }
        // この時点で未処理の桁は 16 ワード未満のはず

        // 未処理の桁が 8 ワード以上あるなら 8 ワード減算を行う。
        if (n & 0x8)
        {
            c = _SUBTRUCT_8WORDS_SBB(c, up, vp, wp);
            up += 8;
            vp += 8;
            wp += 8;
        }
        // この時点で未処理の桁は 8 ワード未満のはず

        // 未処理の桁が 4 ワード以上あるなら 4 ワード減算を行う。
        if (n & 0x4)
        {
            c = _SUBTRUCT_4WORDS_SBB(c, up, vp, wp);
            up += 4;
            vp += 4;
            wp += 4;
        }
        // この時点で未処理の桁は 4 ワード未満のはず

        // 未処理の桁が 2 ワード以上あるなら 2 ワード減算を行う。
        if (n & 0x2)
        {
            c = _SUBTRUCT_2WORDS_SBB(c, up, vp, wp);
            up += 2;
            vp += 2;
            wp += 2;
        }
        // この時点で未処理の桁は 2 ワード未満のはず

        // 未処理の桁が 1 ワード以上あるなら 1 ワード減算を行う。
        if (n & 1)
            c = _SUBTRUCT_UNIT(c, *up++, *vp++, wp++);
        return (c);
    }

    KaratsubaMultiplicationEngine::KaratsubaMultiplicationEngine(bool fixed, ClassicMultiplicationEngine& classic_engine)
        : _fixed(fixed), _classic_engine(classic_engine)
    {
    }

    KaratsubaMultiplicationEngine::~KaratsubaMultiplicationEngine()
    {
    }

    void KaratsubaMultiplicationEngine::Multiply_UX_UX(ThreadContext& tc, __UNIT_TYPE * u_buf, __UNIT_TYPE u_count, __UNIT_TYPE * v_buf, __UNIT_TYPE v_count, __UNIT_TYPE * w_buf)
    {
        ResourceHolderUINT root(tc);

        __UNIT_TYPE n = _MAXIMUM_UNIT(u_count, v_count);
        int lzcnt = _LZCNT_ALT_UNIT(n);
        _UINT32_T log2_n = (__UNIT_TYPE_BIT_COUNT - lzcnt);
        n = (__UNIT_TYPE)1 << log2_n;
        if (u_count == n)
        {
            if (v_count == n)
                Multiply_UX_UX_Karatsuba(tc, log2_n, u_buf, v_buf, w_buf);
            else
            {
                __UNIT_TYPE* new_v_buf;
                __UNIT_TYPE* new_w_buf;
                if (log2_n <= LOG2_N_THRESHOLD_COMPOSITE)
                {
                    __UNIT_TYPE* temp_buf = root.AllocateBlock(n * 3 * __UNIT_TYPE_BIT_COUNT);
                    new_v_buf = &temp_buf[0]; // n words
                    new_w_buf = &temp_buf[n];  // n * 2 words
                }
                else
                {
                    new_v_buf = root.AllocateBlock(n * __UNIT_TYPE_BIT_COUNT);
                    new_w_buf = root.AllocateBlock(n * 2 * __UNIT_TYPE_BIT_COUNT);
                }

                _COPY_MEMORY_UNIT(new_v_buf, v_buf, v_count);
                Multiply_UX_UX_Karatsuba(tc, log2_n, u_buf, new_v_buf, new_w_buf);
                _COPY_MEMORY_UNIT(w_buf, new_w_buf, n + v_count);
            }
        }
        else
        {
            if (v_count == n)
            {
                __UNIT_TYPE* new_u_buf;
                __UNIT_TYPE* new_w_buf;
                if (log2_n <= LOG2_N_THRESHOLD_COMPOSITE)
                {
                    __UNIT_TYPE* temp_buf = root.AllocateBlock(n * 3 * __UNIT_TYPE_BIT_COUNT);
                    new_u_buf = &temp_buf[0]; // n words
                    new_w_buf = &temp_buf[n];  // n * 2 words
                }
                else
                {
                    new_u_buf = root.AllocateBlock(n * __UNIT_TYPE_BIT_COUNT);
                    new_w_buf = root.AllocateBlock(n * 2 * __UNIT_TYPE_BIT_COUNT);
                }


                _COPY_MEMORY_UNIT(new_u_buf, u_buf, u_count);
                Multiply_UX_UX_Karatsuba(tc, log2_n, new_u_buf, v_buf, new_w_buf);
                _COPY_MEMORY_UNIT(w_buf, new_w_buf, u_count + n);
            }
            else
            {
                __UNIT_TYPE* new_u_buf;
                __UNIT_TYPE* new_v_buf;
                __UNIT_TYPE* new_w_buf;
                if (log2_n <= LOG2_N_THRESHOLD_COMPOSITE)
                {
                    __UNIT_TYPE* temp_buf = root.AllocateBlock(n * 4 * __UNIT_TYPE_BIT_COUNT);
                    new_u_buf = &temp_buf[0]; // n words
                    new_v_buf = &temp_buf[n]; // n words
                    new_w_buf = &temp_buf[n + n];  // n * 2 words
                }
                else
                {
                    new_u_buf = root.AllocateBlock(n * __UNIT_TYPE_BIT_COUNT);
                    new_v_buf = root.AllocateBlock(n * __UNIT_TYPE_BIT_COUNT);
                    new_w_buf = root.AllocateBlock(n * 2 * __UNIT_TYPE_BIT_COUNT);
                }

                _COPY_MEMORY_UNIT(new_u_buf, u_buf, u_count);
                _COPY_MEMORY_UNIT(new_v_buf, v_buf, v_count);
                Multiply_UX_UX_Karatsuba(tc, log2_n, new_u_buf, new_v_buf, new_w_buf);
                _COPY_MEMORY_UNIT(w_buf, new_w_buf, u_count + v_count);
            }
        }
    }

    void KaratsubaMultiplicationEngine::Multiply_UX_UX_Karatsuba(ThreadContext & tc, _UINT32_T log2_n, __UNIT_TYPE * u_buf, __UNIT_TYPE * v_buf, __UNIT_TYPE * w_buf)
    {
        if (!_fixed && log2_n < LOG2_N_THRESHOLD_CLASSIC)
        {
            // log2_n が閾値より小さい場合は classic 法で計算する

            __UNIT_TYPE n = (__UNIT_TYPE)1 << log2_n;
            _classic_engine.Multiply_UX_UX(tc, u_buf, n, v_buf, n, w_buf);
        }
        else if (log2_n == 0)
        {
            // log2_n == 0 の場合

            w_buf[0] = _MULTIPLY_UNIT(*u_buf, *v_buf, &w_buf[1]);
#ifdef ENABLED_PERFORMANCE_COUNTER
            if (sizeof(w_buf[0]) == sizeof(_UINT32_T))
                IncrementMULTI32Counter();
            else
                IncrementMULTI64Counter();
#endif
        }
        else
        {
            // log2_n が閾値以上の場合

            ResourceHolderUINT root(tc);

            __UNIT_TYPE n = (__UNIT_TYPE)1 << log2_n;
            _UINT32_T log2_n_half = log2_n - 1;
            __UNIT_TYPE n_half = (__UNIT_TYPE)1 << log2_n_half;

            __UNIT_TYPE* temp_buf;
            __UNIT_TYPE* t1;
            __UNIT_TYPE* t2;
            __UNIT_TYPE* t3;
            __UNIT_TYPE* t;
            if (log2_n <= LOG2_N_THRESHOLD_COMPOSITE)
            {
                temp_buf = root.AllocateBlock((n_half + n_half + n + n) * __UNIT_TYPE_BIT_COUNT);
                t1 = &temp_buf[0]; // n_half words
                t2 = &temp_buf[n_half]; // n_half words
                t3 = &temp_buf[n_half + n_half]; // n words
                t = &temp_buf[n_half + n_half + n]; // n words
            }
            else
            {
                temp_buf = nullptr;
                t1 = root.AllocateBlock(n_half * __UNIT_TYPE_BIT_COUNT);
                t2 = root.AllocateBlock(n_half * __UNIT_TYPE_BIT_COUNT);
                t3 = root.AllocateBlock(n * __UNIT_TYPE_BIT_COUNT);
                t = root.AllocateBlock(n * __UNIT_TYPE_BIT_COUNT);
            }

            Multiply_UX_UX_Karatsuba(tc, log2_n_half, &u_buf[0], &v_buf[0], &w_buf[0]);
            Multiply_UX_UX_Karatsuba(tc, log2_n_half, &u_buf[n_half], &v_buf[n_half], &w_buf[n]);

            SIGN_T t3_sign = SIGN_NEGATIVE;

            if (Compare_UX_UX(n_half, &u_buf[n_half], &u_buf[0]) >= 0)
            {
                Subtruct_UX_UX(n_half, &u_buf[n_half], &u_buf[0], t1);
#ifdef _DEBUG
                root.CheckBlock(log2_n <= LOG2_N_THRESHOLD_COMPOSITE ? temp_buf : t1);
#endif
            }
            else
            {
                t3_sign = INVERT_SIGN(t3_sign);
                Subtruct_UX_UX(n_half, &u_buf[0], &u_buf[n_half], t1);
#ifdef _DEBUG
                root.CheckBlock(log2_n <= LOG2_N_THRESHOLD_COMPOSITE ? temp_buf : t1);
#endif
            }

            if (Compare_UX_UX(n_half, &v_buf[n_half], &v_buf[0]) >= 0)
            {
                Subtruct_UX_UX(n_half, &v_buf[n_half], &v_buf[0], t2);
#ifdef _DEBUG
                root.CheckBlock(log2_n <= LOG2_N_THRESHOLD_COMPOSITE ? temp_buf : t2);
#endif
            }
            else
            {
                t3_sign = INVERT_SIGN(t3_sign);
                Subtruct_UX_UX(n_half, &v_buf[0], &v_buf[n_half], t2);
#ifdef _DEBUG
                root.CheckBlock(log2_n <= LOG2_N_THRESHOLD_COMPOSITE ? temp_buf : t2);
#endif
            }

            Multiply_UX_UX_Karatsuba(tc, log2_n_half, t1, t2, t3);
#ifdef _DEBUG
            root.CheckBlock(log2_n <= LOG2_N_THRESHOLD_COMPOSITE ? temp_buf : t3);
#endif


            // 論理的な t の最大値のビット長は n * __UNIT_TYPE_BIT_COUNT * 2 + 1 で、
            // n ワードのバッファに格納しようとすると 1 ビット分不足するため、
            // 桁上りを t_carry として保存し、最後に t を加算した後の桁上り処理で t_carry も加算することにする。
            char t_carry = Add_UX_UX(n, &w_buf[n], &w_buf[0], t);
#ifdef _DEBUG
            root.CheckBlock(log2_n <= LOG2_N_THRESHOLD_COMPOSITE ? temp_buf : t);
#endif
            if (t3_sign >= 0)
            {
                t_carry += Add_UX_UX(n, t, t3, t);
#ifdef _DEBUG
                root.CheckBlock(log2_n <= LOG2_N_THRESHOLD_COMPOSITE ? temp_buf : t);
#endif
            }
            else
            {
                t_carry -= Subtruct_UX_UX(n, t, t3, t);
#ifdef _DEBUG
                root.CheckBlock(log2_n <= LOG2_N_THRESHOLD_COMPOSITE ? temp_buf : t);
#endif
            }

            if (t_carry < 0)
                throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_multiply_karatsuba.cpp;Multiply_UX_UX_Karatsuba;3");

            char carry = Add_UX_UX(n, &w_buf[n_half], t, &w_buf[n_half]);
            __UNIT_TYPE* w_ptr = &w_buf[n_half + n];
            __UNIT_TYPE count = n_half;

            // t に付随する t に収まり切れなかったビット (t_carry) も1回だけ加算する。
            while (count > 0 && (carry != 0 || t_carry != 0))
            {
                carry = _ADD_UNIT(carry, *w_ptr, t_carry, w_ptr);
                t_carry = 0;
                ++w_ptr;
            }
            if (carry != 0)
            {
                // 最上位桁まで carry が残ってしまった場合

                throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_multiply_karatsuba.cpp;Multiply_UX_UX_Karatsuba;4");
            }
        }
    }


}


/*
 * END OF FILE
 */